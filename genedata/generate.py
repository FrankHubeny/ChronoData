# mypy: disable-error-code="name-defined"
"""Generate a module of classes and tests from the GEDCOM specification,
the BasicStructure and the Xref classes.

This module depends on the following modules which need to be prepared first. The V stands
for a version numer.
- The load module makes the yaml files available as a python dictionary in a specificationsV module
    where N stands for the GEDCOM version.
- The construction of an `Examples` dictionary in the `examplesV` module based on the record
    structure in the specifications and examples provided in the particular structure specification.
- The structure module containing the BasicStructure from which all of these generated classes
    will inherit.
- The xref module containing cross reference identifier classes.
- The constants module for constants used in all modules.
- The message module used for messages in logging and exception handling.
- The methods module containing static methods that can be used in any package.
"""

__all__ = ['Classes', 'Tests']

import importlib
from textwrap import wrap
from typing import Any

from genedata.constants import Default
from genedata.methods import Names, Query


class Classes:
    """Methods to construct classes from the GEDCOM specification."""

    @staticmethod
    def preamble(source: str, version: str) -> str:
        return f"""'''This module of classes was generated by methods in the `{__class__.__name__}` class
of the `{__name__}` module from GEDCOM yaml specification files.  

DO NOT MANUALLY MODIFY THIS MODULE.

The specifications for this module are from the 
[GEDCOM files]({source}) for version {version}.
'''

"""

    @staticmethod
    def tableheader() -> str:
        return """
    |               Specification                | Quantity | Required |  Class Name  |
    | ------------------------------------------ | -------- | -------- | ------------ |"""

    @staticmethod
    def all_listing(
        full_structure: dict[str, dict[str, Any]],
    ) -> str:
        """Generate the __all__ = [] by filling in the list with the modified keys from Structure."""
        count: int = 0
        lines: str = '__all__ = [    # noqa: RUF022'
        for key in full_structure:
            if key not in Default.IGNORE:
                lines = f"{lines}{Default.EOL}{Default.INDENT}'{Names.classname(key)}'{Default.COMMA}"
                count += 1
        if count == 0:
            return Default.EMPTY
        return f'{lines}{Default.EOL}]{Default.EOL}'

    @staticmethod
    def imports() -> str:
        return f"""
import logging
from typing import Any

from genedata.messages import Msg
from genedata.structure import (
    BaseStructure,
    {Default.XREF_FAMILY},
    {Default.XREF_INDIVIDUAL},
    {Default.XREF_MULTIMEDIA},
    {Default.XREF_REPOSITORY},
    {Default.XREF_SHARED_NOTE},
    {Default.XREF_SOURCE},
    {Default.XREF_SUBMITTER},
)
"""

    @staticmethod
    def add_links(text: str, version: str = '7') -> str:
        """Add links missing in the specifications to text with brackets around it."""
        site: str = f'https://gedcom.io/specifications/FamilySearchGEDCOMv{version}.html'
        datatracker: str = 'https://datatracker.ietf.org/doc/html/rfc'
        return (
            text.replace(
                '[BCP 47]',
                f'{Default.EOL}[BCP 47](https://en.wikipedia.org/wiki/IETF_language_tag)',
            )
            .replace(
                '[documented extension tag]',
                f'[documented extension tag]({site}#extension-tags)',
            )
            .replace('[E.123]', '[E.123](https://en.wikipedia.org/wiki/E.123)')
            .replace(
                '[E.164]',
                f'{Default.EOL}[E.164](https://en.wikipedia.org/wiki/E.164)',
            )
            .replace(
                '[exid-types registry]',
                f'{Default.EOL}[exid-types registry]({site}#EXID)',
            )
            .replace(
                '[Extensions]', f'{Default.EOL}[Extensions]({site}#extensions)'
            )
            .replace(
                '[Family Attribute]',
                f'[Family Attribute]({site}#family-attributes)',
            )
            .replace('[Family Event]', f'[Family Event]({site}#family-events)')
            .replace(
                '[File Path datatype]',
                f'[File Path datatype]({site}#file-path)',
            )
            .replace(
                '[Individual Attribute]',
                f'[Individual Attribute]({site}#individual-attributes)',
            )
            .replace(
                '[Individual Event]',
                f'[Individual Event]({site}#INDIVIDUAL_EVENT_STRUCTURE)',
            )
            .replace(
                '[Latter-Day Saint Ordinance]',
                f'[Latter-Day Saint Ordinance]({site}#latter-day-saint-ordinances)',
            )
            .replace('[List]', f'[List]({site}#list){Default.EOL}')
            .replace(
                '[media type]',
                f'[media type]({site}#media-type){Default.EOL}',
            )
            .replace(
                '[Removing data]',
                f'{Default.EOL}[Removing data]({site}#removing-data)',
            )
            .replace(
                '[registry of component subtags] ',
                '[registry of component subtags](https://www.iana.org/assignments/language-subtag-registry/language-subtag-registry)\n',
            )
            .replace('[RFC 3696]', f'[RFC 3696]({datatracker}3696)')
            .replace(
                f'[RFC{Default.EOL}3696]',
                f'{Default.EOL}[RFC 3696]({datatracker}3696)',
            )
            .replace(
                f'[RFC{Default.EOL}3986]',
                f'{Default.EOL}[RFC 3986]({datatracker}3986)',
            )
            .replace(
                '[RFC 3987]', f'{Default.EOL}[RFC 3987]({datatracker}3987)'
            )
            .replace('[RFC 4122]', f'[RFC 4122]({datatracker}4122)')
            .replace(
                '[RFC 5321]', f'{Default.EOL}[RFC 5321]({datatracker}5321)'
            )
            .replace(
                '[RFC 5322]', f'{Default.EOL}[RFC 5322]({datatracker}5322)'
            )
            .replace('. See also ', f'.{Default.EOL}See also ')
            .replace(
                '[The Header and Trailer]',
                f'{Default.EOL}[The Header and Trailer]({site}#the-header)',
            )
            .replace(
                '[whatwg/url]',
                f'{Default.EOL}[whatwg/url](https://url.spec.whatwg.org/)',
            )
            .replace('[YAML file format]', f'[YAML file format]({site})')
        )

    @staticmethod
    def specification(key: str, specs: dict[str, dict[str, Any]]) -> str:
        """Construct the Specification section of the documentation."""
        version: str = specs[Default.YAML_META][Default.YAML_VERSION]
        structure: dict[str, dict[str, Any]] = specs[
            Default.YAML_TYPE_STRUCTURE
        ][key]
        specification: list[str] = list(structure[Default.YAML_SPECIFICATION])
        string_linked: str = Default.EMPTY
        spec: str = """
    GEDCOM Specification:"""
        for string in specification:
            string_linked = Classes.add_links(string, version)
            if (
                Default.EOL not in string_linked
                and len(string_linked) > Default.LINE_LENGTH
            ):
                wrapped = wrap(
                    string_linked,
                    Default.LINE_LENGTH,
                    break_long_words=False,
                    break_on_hyphens=False,
                )
                if len(wrapped) > 1:
                    for index, line in enumerate(wrapped):
                        if index == 0:
                            spec = ''.join(
                                [spec, Default.YAML_WITH_HYPHEN, line]
                            )
                        else:
                            spec = ''.join(
                                [spec, Default.YAML_WITHOUT_HYPHEN, line]
                            )
            elif Default.EOL in string_linked:
                string_linked_split: list[str] = string_linked.split('\n')
                for line in string_linked_split:
                    if len(line) > 80:
                        line_wrapped: list[str] = wrap(
                            line,
                            75,
                            break_long_words=False,
                            break_on_hyphens=False,
                        )
                        if len(line_wrapped) > 1:
                            for index, item in enumerate(line_wrapped):
                                if index == 0:
                                    spec = ''.join(
                                        [spec, Default.YAML_WITH_HYPHEN, item]
                                    )
                                else:
                                    spec = ''.join(
                                        [
                                            spec,
                                            Default.YAML_WITHOUT_HYPHEN,
                                            item,
                                        ]
                                    )
                    else:
                        spec = ''.join(
                            [spec, Default.YAML_WITHOUT_HYPHEN, line]
                        )
            else:
                spec = ''.join([spec, Default.YAML_WITH_HYPHEN, string_linked])
        return spec

    @staticmethod
    def enumerations(key: str, specs: dict[str, dict[str, Any]]) -> str:
        """Construct the Enumerations section of the documentation."""
        structure: dict[str, Any] = specs[Default.YAML_TYPE_STRUCTURE]
        enumeration_set: dict[str, Any] = specs[
            Default.YAML_TYPE_ENUMERATION_SET
        ]
        enumeration: dict[str, Any] = specs[Default.YAML_TYPE_ENUMERATION]
        enumeration_values: str = Default.EMPTY
        if Default.YAML_ENUMERATION_SET in structure[key]:
            enum_set_key: str = Names.stem(
                structure[key][Default.YAML_ENUMERATION_SET]
            )
            enumeration_values = """

    Enumeration Values:"""
            for value in enumeration_set[enum_set_key][
                Default.YAML_ENUMERATION_VALUES
            ]:
                enum_key: str = Names.stem(value)
                enum_tag: str = Default.EMPTY
                if enum_key in enumeration:
                    enum_tag = enumeration[enum_key][Default.YAML_STANDARD_TAG]
                else:
                    enum_tag = structure[enum_key][Default.YAML_STANDARD_TAG]
                enumeration_values = ''.join(
                    [
                        enumeration_values,
                        Default.EOL,
                        Default.INDENT,
                        Default.HYPHEN,
                        Default.SPACE,
                        Default.BRACKET_LEFT,
                        enum_tag,
                        Default.BRACKET_RIGHT,
                        Default.PARENS_LEFT,
                        value,
                        Default.PARENS_RIGHT,
                    ]
                )
        return enumeration_values

    @staticmethod
    def substructures(key: str, specs: dict[str, dict[str, Any]]) -> str:
        """Construct the Substructures section of the documentation."""
        structure: dict[str, dict[str, Any]] = specs[
            Default.YAML_TYPE_STRUCTURE
        ][key]
        class_name: str = Default.EMPTY
        subs: dict[str, str] = {}
        if Default.YAML_SUBSTRUCTURES in structure:
            subs = structure[Default.YAML_SUBSTRUCTURES]
        substructures: str = Default.EMPTY
        if len(subs) > 0:
            substructures = f"""

    Substructures:{Classes.tableheader()}"""

            for subskey, value in subs.items():
                yes: str = Default.NO
                one: str = Default.MANY
                if Default.YAML_CARDINALITY_REQUIRED in value:
                    yes = Default.YES
                if Default.YAML_CARDINALITY_SINGULAR in value:
                    one = Default.ONLY_ONE
                class_name = Names.classname(
                    subskey[subskey.rfind(Default.SLASH) + 1 :]
                )
                substructures = ''.join(
                    [
                        substructures,
                        Default.EOL,
                        Default.INDENT,
                        Default.BAR,
                        Default.SPACE,
                        subskey,
                        Default.SPACE * (42 - len(subskey) + 1),
                        Default.BAR,
                        Default.SPACE,
                        one,
                        Default.SPACE * (8 - len(one) + 1),
                        Default.BAR,
                        Default.SPACE,
                        yes,
                        Default.SPACE * (8 - len(yes) + 1),
                        Default.BAR,
                        Default.SPACE,
                        class_name,
                        Default.SPACE * (12 - len(class_name) + 1),
                        Default.BAR,
                        Default.SPACE,
                    ]
                )
        return substructures

    @staticmethod
    def superstructures(key: str, specs: dict[str, dict[str, Any]]) -> str:
        """Construct the Substructures section of the documentation."""
        structure: dict[str, dict[str, Any]] = specs[
            Default.YAML_TYPE_STRUCTURE
        ][key]
        class_name: str = Default.EMPTY
        supers: dict[str, str] = {}
        if Default.YAML_SUPERSTRUCTURES in structure:
            supers = structure[Default.YAML_SUPERSTRUCTURES]
        superstructures: str = Default.EMPTY
        if len(supers) > 0:
            superstructures = f"""

    Superstructures:{Classes.tableheader()}"""
            for superskey, value in supers.items():
                yes: str = Default.NO
                one: str = Default.MANY
                if Default.YAML_CARDINALITY_REQUIRED in value:
                    yes = Default.YES
                if Default.YAML_CARDINALITY_SINGULAR in value:
                    one = Default.ONLY_ONE
                class_name = Names.classname(
                    superskey[superskey.rfind(Default.SLASH) + 1 :]
                )
                superstructures = ''.join(
                    [
                        superstructures,
                        Default.EOL,
                        Default.INDENT,
                        Default.BAR,
                        Default.SPACE,
                        superskey,
                        Default.SPACE * (42 - len(superskey) + 1),
                        Default.BAR,
                        Default.SPACE,
                        one,
                        Default.SPACE * (8 - len(one) + 1),
                        Default.BAR,
                        Default.SPACE,
                        yes,
                        Default.SPACE * (8 - len(yes) + 1),
                        Default.BAR,
                        Default.SPACE,
                        class_name,
                        Default.SPACE * (12 - len(class_name) + 1),
                        Default.BAR,
                    ]
                )
        return superstructures

    @staticmethod
    def value_of(key: str, specs: dict[str, dict[str, Any]]) -> str:
        """Construct the Enumerations section of the documentation."""
        structure: dict[str, dict[str, Any]] = specs[
            Default.YAML_TYPE_STRUCTURE
        ][key]
        value_of: str = Default.EMPTY
        if Default.YAML_VALUE_OF in structure:
            value_of = """

    Enumeration Value Of:"""
            for value in structure[Default.YAML_VALUE_OF]:
                value_of = f'{value_of}{Default.EOL}{Default.INDENT}{Default.HYPHEN} {value}'
        return value_of

    @staticmethod
    def arguments(key: str, specs: dict[str, dict[str, Any]]) -> str:
        """Construct the Args section of the documentation."""
        structure: dict[str, Any] = specs[Default.YAML_TYPE_STRUCTURE][key]
        args = """
        
    Args:"""
        if (
            Default.YAML_PAYLOAD in structure
            and structure[Default.YAML_PAYLOAD] != 'None'
            and structure[Default.YAML_PAYLOAD] is not None
            and len(structure[Default.YAML_SUPERSTRUCTURES]) > 0
        ):
            args = ''.join(
                [
                    args,
                    Default.EOL,
                    Default.INDENT * 2,
                    Default.CODE_VALUE,
                    ': A value of data type ',
                    structure[Default.YAML_PAYLOAD],
                ]
            )
        if len(structure[Default.YAML_SUPERSTRUCTURES]) == 0 and key != 'HEAD':
            args = ''.join(
                [
                    args,
                    Default.EOL,
                    Default.INDENT * 2,
                    Default.CODE_VALUE,
                    ': A value of data type ',
                    Classes.get_record_datatype(key),
                ]
            )
        if len(structure[Default.YAML_SUBSTRUCTURES]) > 0:
            return ''.join(
                [
                    args,
                    Default.EOL,
                    Default.INDENT * 2,
                    Default.CODE_SUBS,
                    ': A permitted substructure or list of permitted substructures.',
                ]
            )
        return args

    @staticmethod
    def references(key: str, specs: dict[str, Any]) -> str:
        """Construct the References section of the documentation."""
        version: str = specs[Default.YAML_META][Default.YAML_VERSION][0:1]
        uri = specs[Default.YAML_TYPE_STRUCTURE][key][Default.YAML_URI]
        tag = specs[Default.YAML_TYPE_STRUCTURE][key][Default.YAML_STANDARD_TAG]
        return f"""

    References:
    - [GEDCOM {tag} Structure]({uri})
    - [GEDCOM Specifications](https://gedcom.io/specifications/FamilySearchGEDCOMv{version}.html)"""

    @staticmethod
    def get_datatype(structure: dict[str, Any]) -> str:
        """Convert the GEDCOM datatype into python datatype."""
        datatype: str = Default.EMPTY
        if (
            Default.YAML_PAYLOAD in structure
            and structure[Default.YAML_PAYLOAD] is not None
        ):
            datatype = structure[Default.YAML_PAYLOAD]
        match datatype:
            case 'http://www.w3.org/2001/XMLSchema#nonNegativeInteger':
                return 'int'
            case '@<https://gedcom.io/terms/v7/record-INDI>@':
                return Default.XREF_INDIVIDUAL
            case '@<https://gedcom.io/terms/v7/record-FAM>@':
                return Default.XREF_FAMILY
            case '@<https://gedcom.io/terms/v7/record-SUBM>@':
                return Default.XREF_SUBMITTER
            case '@<https://gedcom.io/terms/v7/record-OBJE>@':
                return Default.XREF_MULTIMEDIA
            case '@<https://gedcom.io/terms/v7/record-REPO>@':
                return Default.XREF_REPOSITORY
            case '@<https://gedcom.io/terms/v7/record-SNOTE>@':
                return Default.XREF_SHARED_NOTE
            case '@<https://gedcom.io/terms/v7/record-SOUR>@':
                return Default.XREF_SOURCE
            case _:
                return 'str'

    @staticmethod
    def get_record_datatype(key: str) -> str:
        """Assign a cross reference datatype to specific records."""
        datatype: str = key[7:]
        result: str = Default.EMPTY
        match datatype:
            case Default.TAG_FAM:
                result = Default.XREF_FAMILY
            case Default.TAG_INDI:
                result = Default.XREF_INDIVIDUAL
            case Default.TAG_OBJE:
                result = Default.XREF_MULTIMEDIA
            case Default.TAG_REPO:
                result = Default.XREF_REPOSITORY
            case Default.TAG_SNOTE:
                result = Default.XREF_SHARED_NOTE
            case Default.TAG_SOUR:
                result = Default.XREF_SOURCE
            case Default.TAG_SUBM:
                result = Default.XREF_SUBMITTER
        return result

    @staticmethod
    def init(
        key: str,
        specs: dict[str, dict[str, Any]],
    ) -> str:
        """Construct the global constants and init section of the class."""
        structure: dict[str, Any] = specs[Default.YAML_TYPE_STRUCTURE]
        tag: str = Query.standard_structure_tag(key, specs)
        required: list[str] = Query.required(key, specs)
        single: list[str] = Query.singular(key, specs)
        permitted: list[str] = Query.permitted(key, specs)
        enumset_key: str = Default.EMPTY
        enum_tags: list[str] = []
        enumset_key, enum_tags = Query.enum_key_tags(key, specs)
        value_arg: str = (
            f', {Default.CODE_VALUE}: {Classes.get_datatype(structure[key])}'
        )
        value_init: str = Default.CODE_VALUE
        required_value: str = str(required)
        if len(required) == 0:
            required_value = 'None'
        single_value: str = str(single)
        if len(single) == 0:
            single_value = 'None'
        enum_tags_value = str(enum_tags)
        if len(enum_tags) == 0:
            enum_tags_value = 'None'
        permitted_value: str = str(permitted)
        if len(permitted) == 0:
            subs_arg: str = Default.EMPTY
            subs_init: str = 'None'
            permitted_value = 'None'
        else:
            subs_arg = f'{Default.CODE_SUBS}: Any'
            if len(required) == 0:
                subs_arg = f'{Default.CODE_SUBS}: Any = None'
            subs_init = Default.CODE_SUBS
        separator: str = Default.EMPTY
        if value_arg != Default.EMPTY and subs_arg != Default.EMPTY:  # noqa: PLR1714
            separator = ', '
        payload: str = Query.payload(key, specs)
        if payload == Default.EMPTY or key == 'record-SNOTE':
            value_arg = Default.EMPTY
            value_init = 'None'
            if 'record-' in key:
                value_arg = f', {Default.CODE_VALUE}: {Classes.get_record_datatype(key)}'
                value_init = Default.CODE_VALUE
        deprecation_line: str = Default.EMPTY
        if key in ['ADR1', 'ADR2', 'ADR3']:
            deprecation_line = f'{Default.EOL}        logging.info(Msg.DEPRECATION_WARNING.format(self.class_name))'
        init_line: str = f"""
    def __init__(self{value_arg}{separator}{subs_arg}) -> None:
        super().__init__(
            value={value_init}, 
            subs={subs_init}, 
            key='{key}',
            tag='{tag}',
            supers={Query.supers_count(key, specs)},
            superstructures={Query.superstructures(key, specs)},
            permitted={permitted_value},
            required={required_value},
            single={single_value},
            enumset_key='{enumset_key}',
            enum_tags={enum_tags_value},
            payload='{payload}',
            class_name='{Names.classname(key)}',
        ){deprecation_line}"""
        return init_line  #''.join([init, init_line])

    @staticmethod
    def generate_class(
        key: str,
        specs: dict[str, dict[str, Any]],
        examples: str,
    ) -> str:
        """Generate a single class and its documentation defined by its Structure definition.

        Examples:
            If we have the structure and enumeration set dictionaries constructed in a specs.py file,
            we can use them to build a string that represents the class in the classes module.
            >>> from genedata.examples70 import Examples
            >>> from genedata.generate import Classes
            >>> from genedata.specifications70 import Specs
            >>> map = Classes.generate_class(
            ...     'MAP',
            ...     Specs,
            ...     Examples['MAP'],
            ... )

        Args:
            key: The key of the structure being generated.
            specs: The dictionary of specifications.
            examples: The dictionary of examples to add to this class.
        """
        tag: str = Query.standard_structure_tag(key, specs)
        class_name: str = Names.classname(key)
        parts: str = ''.join(
            [
                Classes.specification(key, specs),
                examples,
                Classes.substructures(key, specs),
                Classes.superstructures(key, specs),
                Classes.enumerations(key, specs),
                Classes.value_of(key, specs),
                Classes.arguments(key, specs),
                Classes.references(key, specs),
            ]
        )
        lines: str = f"""

class {class_name}(BaseStructure):
    '''Store, validate and format the {tag} structure. 
    
    This class was generated by `{__class__.__name__}` from the `{__name__}` module
    using GEDCOM yaml specification files.  Links were added to the specification 
    and tables constructed from the yaml files to aid the user of these classes. 

    DO NOT CHANGE THIS CLASS MANUALLY.  

    {parts}
    '''
    {Classes.init(key, specs)}
    """
        return lines

    @staticmethod
    def all_classes(
        specs: dict[str, dict[str, Any]],
        full_examples: dict[str, str],
    ) -> str:
        """Generate all classes and their documentation defined by the Structure dictionary."""

        lines: str = Default.EMPTY
        class_data: str = Default.EMPTY
        for key, _structure in specs[Default.YAML_TYPE_STRUCTURE].items():
            if key not in Default.IGNORE:
                examples: str = Default.EMPTY
                if key in full_examples:
                    examples = full_examples[key]
                #try:
                class_data = Classes.generate_class(
                    key,
                    specs,
                    examples,
                )
                # except Exception:
                #     logging.info(f'"{key}" failed to generate class.')
                #     raise
                lines = ''.join(
                    [
                        lines,
                        class_data,
                    ]
                )
        return lines

    @staticmethod
    def build_all(specs: dict[str, dict[str, Any]]) -> str:
        """Construct the entire module containing GEDCOM structures converted to classes.

        To build the classes module one either needs a base directory where the yaml files
        are stored, a base url or a specs module that has already been build.  From the
        specs module one will need the Structure and EnumerationSet dictionaries.

        Example:
            This example constructs a string that could be used for a classes module
            using a specification module that has already been constructed.
            >>> from genedata.generate import Classes
            >>> from genedata.specifications70 import Specs
            >>> all = Classes.build_all(Specs)

        Args:
            specs: The specification module generated when the yaml files were loaded.
        """
        version: str = specs[Default.YAML_META][Default.YAML_VERSION]
        source: str = specs[Default.YAML_META][Default.YAML_SOURCE]
        version_no_periods: str = version.replace(Default.PERIOD, Default.EMPTY)
        examples = importlib.import_module(
            f'genedata.examples{version_no_periods}'
        )
        return ''.join(
            [
                Classes.preamble(source, version[0:1]),
                Classes.all_listing(specs[Default.YAML_TYPE_STRUCTURE]),
                Classes.imports(),
                Classes.all_classes(
                    specs,
                    examples.Examples,
                ),
            ]
        )


class Tests:
    """Generate pytest modules for testing the generated classes.

    There are eight tests:
    - All: Validate a mininal instantiation of each structure.  This test covers
        all of the generated classes.
    - Bad Enum: Test that an enumeration value not in the enumeration set fails
        validation.  Only substructures whose values are enumerations are in this test.
    - Bad Payload: Test that the wrong datatype for the value of a structure fails
        the validation test.
    - Bad Singular: Test that a substructure with singular cardinality fails validation
        if two of those singular substructures are included as substructures.
    - Empty Subs: Test that a substructure without a subs argument will trigger a
        TypeError if a subs argument is provided.
    - Empty Value: Test that a substructure without a value argument will trigger a
        TypeError if a value argument is provided.
    - Not Permitted: Test that a substructure that is not permitted fails validation.
        This test covers all of the generated classes.
    - Missing Required: Test that a substructure without its required substructures
        fails validation.  Only structures with required substructions and at least
        one non-required substructure are part of this test.

    These tests are designed to check that the specifications in the yaml files have been
    correctly transferred to the dictionaries and that the generated classes conform
    to the specifications.

    There is one exception to this conforming.  The user explicitly creates cross reference
    identifiers in this application.  They are not hidden in the application.
    The record structures require a cross reference identifer to be entered as the first argument.
    The GEDCOM yaml specification does not allow a value argument for these record structures,
    but they are required in this application.

    The reason for this is that the user of this application is provided the opportunity
    to build multiple genealogies which may conflict with each other.  These genealogies are
    synched with each other through the cross reference identifiers.

    - No Subs: Test that structures without substructures generate the exception:
    """

    @staticmethod
    def get_enum(
        key: str,
        structures: dict[str, dict[str, Any]],
        enumerationsets: dict[str, dict[str, Any]],
        enumerations: dict[str, dict[str, Any]],
    ) -> str:
        if Default.YAML_ENUMERATION_SET in structures[key]:
            enum_set_key = Names.keyname(
                structures[key][Default.YAML_ENUMERATION_SET]
            )
            enum_value = enumerationsets[enum_set_key][
                Default.YAML_ENUMERATION_VALUES
            ][0]
            enum_key = Names.keyname(enum_value)
            if enum_key in enumerations:
                return str(enumerations[enum_key][Default.YAML_STANDARD_TAG])
        return Default.EMPTY

    @staticmethod
    def get_singular(
        key: str,
        structures: dict[str, Any],
        enumerationsets: dict[str, Any],
        enumerations: dict[str, Any],
    ) -> tuple[str, str]:
        """Get one singular substructure."""
        singular: str = Default.EMPTY
        name: str = Default.EMPTY
        for uri, cardinality in structures[key][
            Default.YAML_SUBSTRUCTURES
        ].items():
            if Default.CARDINALITY_SINGULAR in cardinality:
                sub_key = Names.keyname(uri)
                name = f"'{Names.classname(sub_key)}'"
                sub_value = Tests.get_value(
                    sub_key, structures, enumerationsets, enumerations
                )
                sub_required = Tests.get_required(
                    sub_key, structures, enumerationsets, enumerations
                )
                class_name = Names.classname(sub_key)
                if sub_required != Default.EMPTY and sub_value == Default.EMPTY:
                    singular = f'{singular}{Default.CODE_CLASS}{class_name}({sub_required})'
                else:
                    singular = f'{singular}{Default.CODE_CLASS}{class_name}({sub_value})'
                break
        return name, singular

    @staticmethod
    def get_one_not_required(
        key: str,
        structures: dict[str, Any],
        enumerationsets: dict[str, Any],
        enumerations: dict[str, Any],
    ) -> str:
        """Get one substructure with its values and required substructure that is not required."""
        not_required: str = Default.EMPTY
        for uri, cardinality in structures[key][
            Default.YAML_SUBSTRUCTURES
        ].items():
            if Default.CARDINALITY_REQUIRED not in cardinality:
                sub_key = Names.keyname(uri)
                sub_value = Tests.get_value(
                    sub_key, structures, enumerationsets, enumerations
                )
                sub_not_required = Tests.get_required(
                    sub_key, structures, enumerationsets, enumerations
                )
                class_name = Names.classname(sub_key)
                if sub_not_required != Default.EMPTY:
                    if sub_value != Default.EMPTY:
                        not_required = f'{Default.CODE_CLASS}{class_name}({sub_value}, {sub_not_required})'
                    else:
                        not_required = f'{Default.CODE_CLASS}{class_name}({sub_not_required})'
                else:
                    # if sub_value != Default.EMPTY:
                    not_required = (
                        f'{Default.CODE_CLASS}{class_name}({sub_value})'
                    )
                    # else:
                    #     not_required = f'{Default.CODE_CLASS}{class_name}()'
                break
        return not_required

    @staticmethod
    def get_required(
        key: str,
        structures: dict[str, Any],
        enumerationsets: dict[str, Any],
        enumerations: dict[str, Any],
    ) -> str:
        more_than_one: bool = False
        required: str = Default.EMPTY
        for uri, cardinality in structures[key][
            Default.YAML_SUBSTRUCTURES
        ].items():
            if Default.CARDINALITY_REQUIRED in cardinality:
                sub_key = Names.keyname(uri)
                sub_value = Tests.get_value(
                    sub_key, structures, enumerationsets, enumerations
                )
                sub_required = Tests.get_required(
                    sub_key, structures, enumerationsets, enumerations
                )
                class_name = Names.classname(sub_key)
                if required != Default.EMPTY:
                    # if sub_required != Default.EMPTY:
                    #     required = f'{required}, {Default.CODE_CLASS}{class_name}({sub_value}({sub_required}))'
                    # else:
                    more_than_one = True
                    required = f'{required}, {Default.CODE_CLASS}{class_name}({sub_value})'
                else:  # noqa: PLR5501
                    if (
                        sub_required != Default.EMPTY
                        and sub_value == Default.EMPTY
                    ):
                        required = f'{required}{Default.CODE_CLASS}{class_name}({sub_required})'
                    elif sub_required != Default.EMPTY:
                        required = f'{required}{Default.CODE_CLASS}{class_name}({sub_value}, {sub_required})'
                    else:
                        required = f'{required}{Default.CODE_CLASS}{class_name}({sub_value})'
        if required == Default.EMPTY:
            return required
        if more_than_one:
            return f'[{required}]'
        return required

    @staticmethod
    def get_message(key: str, payload: str) -> str:
        match payload:
            case 'http://www.w3.org/2001/XMLSchema#string':
                match key:
                    case 'record-SNOTE':
                        return 'NOT_SHARED_NOTE_XREF'
                    case _:
                        return 'NOT_STRING'
            case 'https://gedcom.io/terms/v7/type-Enum':
                return 'NOT_STRING'
            case 'http://www.w3.org/2001/XMLSchema#nonNegativeInteger':
                return 'NOT_INTEGER'
            case '@<https://gedcom.io/terms/v7/record-FAM>@':
                return 'NOT_FAMILY_XREF'
            case '@<https://gedcom.io/terms/v7/record-INDI>@':
                return 'NOT_INDIVIDUAL_XREF'
            case '@<https://gedcom.io/terms/v7/record-SUBM>@':
                return 'NOT_SUBMITTER_XREF'
            case 'https://gedcom.io/terms/v7/type-List#Text':
                return 'NOT_STRING'
            case 'http://www.w3.org/2001/XMLSchema#Language':
                return 'NOT_STRING'
            case 'https://gedcom.io/terms/v7/type-Date#period':
                return 'NOT_STRING'
            case 'https://gedcom.io/terms/v7/type-List#Enum':
                return 'NOT_STRING'
            case 'https://gedcom.io/terms/v7/type-Date#exact':
                return 'NOT_STRING'
            case 'https://gedcom.io/terms/v7/type-Date':
                return 'NOT_STRING'
            case 'https://gedcom.io/terms/v7/type-FilePath':
                return 'NOT_STRING'
            case 'http://www.w3.org/ns/dcat#mediaType':
                return 'NOT_STRING'
            case 'https://gedcom.io/terms/v7/type-Name':
                return 'NOT_STRING'
            case 'https://gedcom.io/terms/v7/type-Age':
                return 'NOT_STRING'
            case '@<https://gedcom.io/terms/v7/record-OBJE>@':
                return 'NOT_MULTIMEDIA_XREF'
            case '@<https://gedcom.io/terms/v7/record-REPO>@':
                return 'NOT_REPOSITORY_XREF'
            case '@<https://gedcom.io/terms/v7/record-SNOTE>@':
                return 'NOT_SHARED_NOTE_XREF'
            case '@<https://gedcom.io/terms/v7/record-SOUR>@':
                return 'NOT_SOURCE_XREF'
            case 'https://gedcom.io/terms/v7/type-Time':
                return 'NOT_STRING'
            case _:
                return 'NOT_STRING'

    @staticmethod
    def get_value(
        key: str,
        structures: dict[str, dict[str, Any]],
        enumerationsets: dict[str, dict[str, Any]],
        enumerations: dict[str, dict[str, Any]],
        y: bool = True,
    ) -> str:
        enum: str = Tests.get_enum(
            key, structures, enumerationsets, enumerations
        )
        payload: str = str(structures[key][Default.YAML_PAYLOAD])
        match payload:
            case 'http://www.w3.org/2001/XMLSchema#string':
                match key:
                    case 'LATI':
                        return "'N10.1'"
                    case 'LONG':
                        return "'E10.1'"
                    case 'record-SNOTE':
                        return 'snote'
                    case 'TAG':
                        return "'tag uri'"
                    case _:
                        return "'abc'"
            case 'Y|<NULL>':
                if y:
                    return "'Y'"
                return "''"
            case 'None':
                match key:
                    case 'record-FAM':
                        return 'fam'
                    case 'record-INDI':
                        return 'indi'
                    case 'record-OBJE':
                        return 'obje'
                    case 'record-REPO':
                        return 'repo'
                    case 'record-SOUR':
                        return 'sour'
                    case 'record-SUBM':
                        return 'subm'
                    case _:
                        return Default.EMPTY
            case 'https://gedcom.io/terms/v7/type-Enum':
                return f"'{enum}'"
            case 'http://www.w3.org/2001/XMLSchema#nonNegativeInteger':
                return '1'
            case '@<https://gedcom.io/terms/v7/record-FAM>@':
                return 'fam'
            case '@<https://gedcom.io/terms/v7/record-INDI>@':
                return 'indi'
            case '@<https://gedcom.io/terms/v7/record-SUBM>@':
                return 'subm'
            case 'https://gedcom.io/terms/v7/type-List#Text':
                return "'text'"
            case 'http://www.w3.org/2001/XMLSchema#Language':
                return "'en-US'"
            case 'https://gedcom.io/terms/v7/type-Date#period':
                return "'FROM 1 JAN 2000 TO 1 JAN 2001'"
            case 'https://gedcom.io/terms/v7/type-List#Enum':
                return f"'{enum}'"
            case 'https://gedcom.io/terms/v7/type-Date#exact':
                return "'1 JAN 2000'"
            case 'https://gedcom.io/terms/v7/type-Date':
                return "'1 JAN 2000'"
            case 'https://gedcom.io/terms/v7/type-FilePath':
                return "'dir/to/somewhere/'"
            case 'http://www.w3.org/ns/dcat#mediaType':
                return "'text/html'"
            case 'https://gedcom.io/terms/v7/type-Name':
                return "'John /Doe/'"
            case 'https://gedcom.io/terms/v7/type-Age':
                return "'> 10y 2m 1d'"
            case '@<https://gedcom.io/terms/v7/record-OBJE>@':
                return 'obje'
            case '@<https://gedcom.io/terms/v7/record-REPO>@':
                return 'repo'
            case '@<https://gedcom.io/terms/v7/record-SNOTE>@':
                return 'snote'
            case '@<https://gedcom.io/terms/v7/record-SOUR>@':
                return 'sour'
            case _:
                return "'12:12:12'"

    @staticmethod
    def there_are_required_substructures(substructures: dict[str, str]) -> bool:
        """Return true if there dictionary of substructures contains a required substructure.

        Args:
            substructures: The subdictionary of Structure containing the uri as key
                and its cardinality code as value.  The cardinality code `{1:`
                signals a required substructure.
        """
        for _key, cardinality in substructures.items():
            if Default.CARDINALITY_REQUIRED in cardinality:
                return True
        return False

    @staticmethod
    def preamble(
        test: str,
        add_pytest: int = 0,
        firstline: str = Default.EMPTY,
        version: str = '70',
    ) -> str:
        """Construct a document to describe a module containing a set of tests."""
        version_no_periods: str = version.replace(Default.PERIOD, Default.EMPTY)
        match add_pytest:
            case 0:
                pytest: str = f"""from genedata.build import Genealogy   # noqa: I001
import genedata.classes{version_no_periods} as {Default.CODE_CLASS_VARIABLE}"""
            case 1:
                pytest = f"""import pytest   # noqa: I001
import re

import genedata.classes{version_no_periods} as {Default.CODE_CLASS_VARIABLE}
from genedata.build import Genealogy
from genedata.messages import Msg"""
            case 2:
                pytest = f"""import pytest   # noqa: I001
import re

import genedata.classes{version_no_periods} as {Default.CODE_CLASS_VARIABLE}
from genedata.build import Genealogy"""
        return f"""{firstline}'''This module contains {test} tests to be run with pytest.

The file was generated by methods of the `{__class__.__name__}` class in the `{__name__}` module.

DO NOT MODIFY THIS FILE.
'''

{pytest}


{Default.CODE_GENEALOGY_VARIABLE} = Genealogy()
fam = {Default.CODE_GENEALOGY}family_xref('1')
indi = {Default.CODE_GENEALOGY}individual_xref('2')
obje = {Default.CODE_GENEALOGY}multimedia_xref('3')
repo = {Default.CODE_GENEALOGY}repository_xref('4')
snote = {Default.CODE_GENEALOGY}shared_note_xref('5', 'a note')
sour = {Default.CODE_GENEALOGY}source_xref('6')
subm = {Default.CODE_GENEALOGY}submitter_xref('7')
"""

    @staticmethod
    def all(specs: dict[str, dict[str, Any]]) -> str:
        """Generate a test for each generated class.

        All generated classes are validated with their required substructures, if any.

        Args:
            specs: The specification dictionary derived from GEDCOM yaml files.
        """

        def write(key: str, value: str, subs: str) -> str:
            """Write out a single test for the class `key` with value `value`."""
            separator: str = Default.EMPTY
            if value != Default.EMPTY and subs != Default.EMPTY:  # noqa: PLR1714
                separator = ', '
            class_name: str = Names.classname(key)
            lines: str = f"""

def test_{test_name.lower().replace(Default.SPACE, Default.UNDERLINE)}_{class_name}() -> None:
    '''Validate the `{class_name}` structure with a value and required substructures.'''
    m = {Default.CODE_CLASS}{class_name}({value}{separator}{subs})
    assert m.validate()
"""
            return lines

        version: str = specs[Default.YAML_META][Default.YAML_VERSION]
        structures: dict[str, dict[str, Any]] = specs[
            Default.YAML_TYPE_STRUCTURE
        ]
        enumerationsets: dict[str, dict[str, Any]] = specs[
            Default.YAML_TYPE_ENUMERATION_SET
        ]
        enumerations: dict[str, dict[str, Any]] = specs[
            Default.YAML_TYPE_ENUMERATION
        ]
        test_name: str = 'All'
        lines: str = Tests.preamble(test_name, version=version)
        value: str = Default.EMPTY
        subs: str = Default.EMPTY
        y: bool = True
        for key in structures:
            if key not in Default.IGNORE:
                value = Tests.get_value(
                    key,
                    structures,
                    enumerationsets,
                    enumerations,
                    y,
                )
                y = not y
                subs = Tests.get_required(
                    key, structures, enumerationsets, enumerations
                )
                lines = ''.join([lines, write(key, value, subs)])
        return lines

    @staticmethod
    def not_permitted(specs: dict[str, dict[str, Any]]) -> str:
        """Generate a test verifying that a substructure not in its permitted list is rejected.

        All generated classes are tested.

        Args:
            specs: The specification dictionary derived from GEDCOM yaml files.
        """

        def write(key: str, value: str, subs: str) -> str:
            """Write out a single test for the class `key` with value `value`."""
            separator: str = Default.EMPTY
            if value != Default.EMPTY and subs != Default.EMPTY:  # noqa: PLR1714
                separator = ', '
            class_name: str = Names.classname(key)
            lines: str = f"""

def test_{test_name.lower().replace(Default.SPACE, Default.UNDERLINE)}_{class_name}() -> None:
    '''Validate the `{class_name}` structure with a value and required substructures.'''
    m = {Default.CODE_CLASS}{class_name}({value}{separator}{subs})
    with pytest.raises(
        ValueError, match=re.escape(Msg.NOT_PERMITTED.format('RecordIndi', m.permitted, m.class_name))
    ):
        assert m.validate()
"""
            return lines

        version: str = specs[Default.YAML_META][Default.YAML_VERSION]
        structures: dict[str, dict[str, Any]] = specs[
            Default.YAML_TYPE_STRUCTURE
        ]
        enumerationsets: dict[str, dict[str, Any]] = specs[
            Default.YAML_TYPE_ENUMERATION_SET
        ]
        enumerations: dict[str, dict[str, Any]] = specs[
            Default.YAML_TYPE_ENUMERATION
        ]
        test_name: str = 'Not Permitted'
        not_permitted_sub: str = f'{Default.CODE_CLASS}RecordIndi(indi)'
        lines: str = Tests.preamble(test_name, add_pytest=1, version=version)
        value: str = Default.EMPTY
        subs: str = Default.EMPTY
        for key in structures:
            if key not in Default.IGNORE:
                value = Tests.get_value(
                    key,
                    structures,
                    enumerationsets,
                    enumerations,
                )
                subs = Tests.get_required(
                    key, structures, enumerationsets, enumerations
                )
                if subs == Default.EMPTY:
                    subs = not_permitted_sub
                elif Default.BRACKET_LEFT in subs:
                    subs = subs.replace(
                        Default.BRACKET_LEFT,
                        f'{Default.BRACKET_LEFT}{not_permitted_sub}, ',
                    )
                else:
                    subs = f'[{not_permitted_sub}, {subs}]'
                if len(structures[key][Default.YAML_SUBSTRUCTURES]) > 0:
                    lines = ''.join([lines, write(key, value, subs)])
        return lines

    @staticmethod
    def bad_payload(specs: dict[str, dict[str, Any]]) -> str:
        """Generate a test verifying that bad payload is rejected.

        All generated classes are tested.

        Args:
            specs: The specification dictionary derived from GEDCOM yaml files.
        """

        def write(key: str, value: str, subs: str, error_message: str) -> str:
            """Write out a single test for the class `key` with value `value`."""
            separator: str = Default.EMPTY
            if value != Default.EMPTY and subs != Default.EMPTY:  # noqa: PLR1714
                separator = ', '
            class_name: str = Names.classname(key)
            lines: str = f"""

def test_{test_name.lower().replace(Default.SPACE, Default.UNDERLINE)}_{class_name}() -> None:
    '''Validate that the `{class_name}` structure rejects a value not in its payload datatype.'''
    m = {Default.CODE_CLASS}{class_name}({value}{separator}{subs})
    with pytest.raises(
        ValueError, match=re.escape(Msg.{error_message}.format('-1', m.class_name))
    ):
        assert m.validate()
"""
            return lines

        version: str = specs[Default.YAML_META][Default.YAML_VERSION]
        structures: dict[str, dict[str, Any]] = specs[
            Default.YAML_TYPE_STRUCTURE
        ]
        enumerationsets: dict[str, dict[str, Any]] = specs[
            Default.YAML_TYPE_ENUMERATION_SET
        ]
        enumerations: dict[str, dict[str, Any]] = specs[
            Default.YAML_TYPE_ENUMERATION
        ]
        test_name: str = 'Bad Payload'
        error_message: str = 'NOT_STRING'
        lines: str = Tests.preamble(
            test_name,
            add_pytest=1,
            firstline='# mypy: disable-error-code="arg-type, unused-ignore"\n',
            version=version,
        )
        value: str = '-1'
        subs: str = Default.EMPTY
        for key in structures:
            if (
                key not in Default.IGNORE
                and structures[key][Default.YAML_PAYLOAD] is not None
            ):
                subs = Tests.get_required(
                    key, structures, enumerationsets, enumerations
                )
                error_message = Tests.get_message(
                    key, structures[key][Default.YAML_PAYLOAD]
                )
                lines = ''.join([lines, write(key, value, subs, error_message)])
        return lines

    @staticmethod
    def bad_enum(specs: dict[str, dict[str, Any]]) -> str:
        """Generate a test verifying that a bad enumeration value is rejected.

        All generated classes are tested.

        Args:
            specs: The specification dictionary derived from GEDCOM yaml files.
        """

        def write(key: str, value: str, subs: str) -> str:
            """Write out a single test for the class `key` with value `value`."""
            separator: str = Default.EMPTY
            if value != Default.EMPTY and subs != Default.EMPTY:  # noqa: PLR1714
                separator = ', '
            class_name: str = Names.classname(key)
            lines: str = f"""

def test_{test_name.lower().replace(Default.SPACE, Default.UNDERLINE)}_{class_name}() -> None:
    '''Validate the `{class_name}` structure with a bad enumeration value and required substructures.'''
    m = {Default.CODE_CLASS}{class_name}({value}{separator}{subs})
    with pytest.raises(
        ValueError, match=re.escape(Msg.NOT_VALID_ENUM.format({value}, m.enum_tags, m.class_name))
    ):
        assert m.validate()
"""
            return lines

        version: str = specs[Default.YAML_META][Default.YAML_VERSION]
        structures: dict[str, dict[str, Any]] = specs[
            Default.YAML_TYPE_STRUCTURE
        ]
        enumerationsets: dict[str, dict[str, Any]] = specs[
            Default.YAML_TYPE_ENUMERATION_SET
        ]
        enumerations: dict[str, dict[str, Any]] = specs[
            Default.YAML_TYPE_ENUMERATION
        ]
        test_name: str = 'Bad Enum'
        bad_enum: str = "'XYZ1234567890'"
        lines: str = Tests.preamble(test_name, add_pytest=1, version=version)
        subs: str = Default.EMPTY
        for key, structure in structures.items():
            if (
                key not in Default.IGNORE
                and Default.YAML_ENUMERATION_SET in structure
            ):
                subs = Tests.get_required(
                    key, structures, enumerationsets, enumerations
                )
                lines = ''.join([lines, write(key, bad_enum, subs)])
        return lines

    @staticmethod
    def bad_singular(specs: dict[str, dict[str, Any]]) -> str:
        """Generate a test verifying that a substructure with a single constraint is rejected
        if entered more than once.

        Only structures with permitted single substructures are tested.

        Args:
            specs: The specification dictionary derived from GEDCOM yaml files.
        """

        def write(key: str, value: str, subs: str, name: str) -> str:
            """Write out a single test for the class `key` with value `value`."""
            separator: str = Default.EMPTY
            if value != Default.EMPTY and subs != Default.EMPTY:  # noqa: PLR1714
                separator = ', '
            class_name: str = Names.classname(key)
            lines: str = f"""

def test_{test_name.lower().replace(Default.SPACE, Default.UNDERLINE)}_{class_name}() -> None:
    '''Validate the `{class_name}` structure with a single substructure that is repeated.'''
    m = {Default.CODE_CLASS}{class_name}({value}{separator}{subs})
    with pytest.raises(
        ValueError, match=re.escape(Msg.ONLY_ONE_PERMITTED.format({name}, m.class_name))
    ):
        assert m.validate()
"""
            return lines

        version: str = specs[Default.YAML_META][Default.YAML_VERSION]
        structures: dict[str, dict[str, Any]] = specs[
            Default.YAML_TYPE_STRUCTURE
        ]
        enumerationsets: dict[str, dict[str, Any]] = specs[
            Default.YAML_TYPE_ENUMERATION_SET
        ]
        enumerations: dict[str, dict[str, Any]] = specs[
            Default.YAML_TYPE_ENUMERATION
        ]
        test_name: str = 'Bad Singular'
        lines: str = Tests.preamble(test_name, add_pytest=1, version=version)
        subs: str = Default.EMPTY
        for key, structure in structures.items():
            value = Tests.get_value(
                key,
                structures,
                enumerationsets,
                enumerations,
            )
            if key not in Default.IGNORE:
                for _subkey, subvalue in structure[
                    Default.YAML_SUBSTRUCTURES
                ].items():
                    if Default.CARDINALITY_SINGULAR in subvalue:
                        subs = Tests.get_required(
                            key, structures, enumerationsets, enumerations
                        )
                        name, singular = Tests.get_singular(
                            key, structures, enumerationsets, enumerations
                        )
                        if subs != Default.EMPTY:
                            subs = ''.join(
                                [
                                    Default.BRACKET_LEFT,
                                    singular,
                                    ', ',
                                    singular,
                                    ', ',
                                    subs.replace(
                                        Default.BRACKET_LEFT, Default.EMPTY
                                    ).replace(
                                        Default.BRACKET_RIGHT, Default.EMPTY
                                    ),
                                    Default.BRACKET_RIGHT,
                                ]
                            )
                        else:
                            subs = ''.join(['[', singular, ', ', singular, ']'])
                        lines = ''.join([lines, write(key, value, subs, name)])
                        break
        return lines

    @staticmethod
    def missing_required(specs: dict[str, dict[str, Any]]) -> str:
        """Generate a test verifying that a substructure without its required substructures is rejected.

        Only structures with a permitted substructure besides the required substructures are tested.

        Args:
            specs: The specification dictionary derived from GEDCOM yaml files.
        """

        def write(key: str, value: str, subs: str) -> str:
            """Write out a single test for the class `key` with value `value`."""
            separator: str = Default.EMPTY
            if value != Default.EMPTY and subs != Default.EMPTY:  # noqa: PLR1714
                separator = ', '
            class_name: str = Names.classname(key)
            lines: str = f"""

def test_{test_name.lower().replace(Default.SPACE, Default.UNDERLINE)}_{class_name}() -> None:
    '''Validate the `{class_name}` structure with a single substructure that is repeated.'''
    m = {Default.CODE_CLASS}{class_name}({value}{separator}{subs})
    with pytest.raises(
        ValueError, match=re.escape(Msg.MISSING_REQUIRED.format(m.required, m.class_name))
    ):
        assert m.validate()
"""
            return lines

        version: str = specs[Default.YAML_META][Default.YAML_VERSION]
        structures: dict[str, dict[str, Any]] = specs[
            Default.YAML_TYPE_STRUCTURE
        ]
        enumerationsets: dict[str, dict[str, Any]] = specs[
            Default.YAML_TYPE_ENUMERATION_SET
        ]
        enumerations: dict[str, dict[str, Any]] = specs[
            Default.YAML_TYPE_ENUMERATION
        ]
        test_name: str = 'Missing Required'
        lines: str = Tests.preamble(test_name, add_pytest=1, version=version)
        subs: str = Default.EMPTY
        for key, structure in structures.items():
            if (
                key not in Default.IGNORE
                and Tests.there_are_required_substructures(
                    structure[Default.YAML_SUBSTRUCTURES]
                )
            ):
                value = Tests.get_value(
                    key,
                    structures,
                    enumerationsets,
                    enumerations,
                )
                subs = Tests.get_one_not_required(
                    key, structures, enumerationsets, enumerations
                )
                if subs != Default.EMPTY:
                    lines = ''.join([lines, write(key, value, subs)])
        return lines

    @staticmethod
    def empty_subs(specs: dict[str, dict[str, Any]]) -> str:
        """Generate tests verifying that a substructure without substructures in its specification
        cannot enter a substructure.

        Only structures with a value of `{}` for the `substructures` key are tested.

        Args:
            specs: The specification dictionary derived from GEDCOM yaml files.
        """

        def write(key: str, value: str, subs: str = 'gc.Phrase("hi")') -> str:
            """Write out a single test for the class `key` with value `value`."""
            separator: str = Default.EMPTY
            if value != Default.EMPTY and subs != Default.EMPTY:  # noqa: PLR1714
                separator = ', '
            class_name: str = Names.classname(key)
            lines: str = f"""

def test_{test_name.lower().replace(Default.SPACE, Default.UNDERLINE)}_{class_name}() -> None:
    '''Validate the `{class_name}` without substructures cannot receive a substructure.'''
    with pytest.raises(
        TypeError, match=re.escape("{class_name}.__init__() takes 2 positional arguments but 3 were given")
    ):
        {Default.CODE_CLASS}{class_name}({value}{separator}{subs})  # type: ignore[call-arg]
"""
            return lines

        version: str = specs[Default.YAML_META][Default.YAML_VERSION]
        structures: dict[str, dict[str, Any]] = specs[
            Default.YAML_TYPE_STRUCTURE
        ]
        enumerationsets: dict[str, dict[str, Any]] = specs[
            Default.YAML_TYPE_ENUMERATION_SET
        ]
        enumerations: dict[str, dict[str, Any]] = specs[
            Default.YAML_TYPE_ENUMERATION
        ]
        test_name: str = 'Empty Subs'
        lines: str = Tests.preamble(test_name, add_pytest=2, version=version)
        for key, structure in structures.items():
            if (
                key not in Default.IGNORE
                and len(structure[Default.YAML_SUBSTRUCTURES]) == 0
                and structure[Default.YAML_PAYLOAD] != 'None'
            ):
                value = Tests.get_value(
                    key,
                    structures,
                    enumerationsets,
                    enumerations,
                )
                lines = ''.join([lines, write(key, value)])
        return lines

    @staticmethod
    def empty_value(specs: dict[str, dict[str, Any]]) -> str:
        """Generate tests verifying that a substructure without substructures in its specification
        cannot enter a substructure.

        Only structures with a value of `None` for the `payload` key are tested.

        Args:
            specs: The specification dictionary derived from GEDCOM yaml files.
        """

        def write(key: str, value: str, subs: str = 'gc.Phrase("hi")') -> str:
            """Write out a single test for the class `key` with value `value`."""
            separator: str = Default.EMPTY
            if value != Default.EMPTY and subs != Default.EMPTY:  # noqa: PLR1714
                separator = ', '
            class_name: str = Names.classname(key)
            lines: str = f"""

def test_{test_name.lower().replace(Default.SPACE, Default.UNDERLINE)}_{class_name}() -> None:
    '''Validate that `{class_name}` without a value argument cannot receive a value argument.'''
    with pytest.raises(
        TypeError, match=re.escape("{class_name}.__init__() got an unexpected keyword argument 'value'")
    ):
        {Default.CODE_CLASS}{class_name}(value={value}{separator}subs={subs})  # type: ignore[call-arg]
"""
            return lines

        version: str = specs[Default.YAML_META][Default.YAML_VERSION]
        structures: dict[str, dict[str, Any]] = specs[
            Default.YAML_TYPE_STRUCTURE
        ]
        enumerationsets: dict[str, dict[str, Any]] = specs[
            Default.YAML_TYPE_ENUMERATION_SET
        ]
        enumerations: dict[str, dict[str, Any]] = specs[
            Default.YAML_TYPE_ENUMERATION
        ]
        test_name: str = 'Empty Value'
        value: str = "'hi'"
        lines: str = Tests.preamble(test_name, add_pytest=2, version=version)
        for key, structure in structures.items():
            if (
                key not in Default.IGNORE
                and structure[Default.YAML_PAYLOAD] is None
                and key
                not in [
                    'record-FAM',
                    'record-INDI',
                    'record-OBJE',
                    'record-REPO',
                    'record-SNOTE',
                    'record-SOUR',
                    'record-SUBM',
                ]
            ):
                subs = Tests.get_required(
                    key,
                    structures,
                    enumerationsets,
                    enumerations,
                )
                if subs == Default.EMPTY:
                    subs = 'None'
                lines = ''.join([lines, write(key, value, subs)])
        return lines
