# mypy: disable-error-code="name-defined"
"""Generate a module of classes and tests from specification and the BasicStructure and Xref classes.

This module depends on the following modules which need to be prepared first. The V stands
for a version numer.
- The load module makes the yaml files available as a python dictionary in a specificationsV module
    where N stands for the GEDCOM version.
- The construction of an ExampleV dictionary in the examples module based on the record
    structure in the specifications and examples provided in the particular structure specification.
- The structure module containing the BasicStructure from which all of these generated classes
    will inherit.
- The xref module containing cross reference identifier classes.
- The constants module for constants used in all modules.
- The message module used for messages in logging and exception handling.
- The methods module containing static methods that can be used in any package.

It the examples module

"""

__all__ = ['Classes', 'Tests']


from textwrap import wrap
from typing import Any

from genedata.constants import Config, Default
from genedata.methods import Names


class Classes:
    """Methods to construct classes from the GEDCOM specification."""

    @staticmethod
    def preamble(source: str, version: str) -> str:
        return f"""'''This module of classes was generated by methods in the `{__class__.__name__}` class
of the `{__name__}` module from GEDCOM yaml specification files.  

DO NOT MANUALLY MODIFY THIS MODULE.

The specifications for this module are from the 
[GEDCOM files]({source}) for version {version}.
'''

"""

    @staticmethod
    def tableheader() -> str:
        return """
    |               Specification                | Quantity | Required |  Class Name  |
    | ------------------------------------------ | -------- | -------- | ------------ |"""

    @staticmethod
    def all_listing(
        full_structure: dict[str, dict[str, Any]],
    ) -> str:
        """Generate the __all__ = [] by filling in the list with the modified keys from Structure."""
        count: int = 0
        lines: str = '__all__ = [    # noqa: RUF022'
        for key in full_structure:
            if key not in [Default.CONT, Default.TRLR]:
                lines = f"{lines}{Default.EOL}{Default.INDENT}'{Names.classname(key)}'{Default.COMMA}"
                count += 1
        if count == 0:
            return Default.EMPTY
        return f'{lines}{Default.EOL}]{Default.EOL}'

    @staticmethod
    def imports() -> str:
        return f"""
import logging
from typing import Any

from genedata.messages import Msg
from genedata.structure import (
    BaseStructure,
    {Default.XREF_FAMILY},
    {Default.XREF_INDIVIDUAL},
    {Default.XREF_MULTIMEDIA},
    {Default.XREF_REPOSITORY},
    {Default.XREF_SHARED_NOTE},
    {Default.XREF_SOURCE},
    {Default.XREF_SUBMITTER},
)
"""

    @staticmethod
    def add_links(text: str) -> str:
        """Add links missing in the specifications to text with brackets around it."""
        site: str = f'https://gedcom.io/specifications/FamilySearchGEDCOMv{Config.VERSION}.html'
        datatracker: str = 'https://datatracker.ietf.org/doc/html/rfc'
        return (
            text.replace(
                '[BCP 47]',
                f'{Default.EOL}[BCP 47](https://en.wikipedia.org/wiki/IETF_language_tag)',
            )
            .replace(
                '[documented extension tag]',
                f'[documented extension tag]({site}#extension-tags)',
            )
            .replace('[E.123]', '[E.123](https://en.wikipedia.org/wiki/E.123)')
            .replace(
                '[E.164]',
                f'{Default.EOL}[E.164](https://en.wikipedia.org/wiki/E.164)',
            )
            .replace(
                '[exid-types registry]',
                f'{Default.EOL}[exid-types registry]({site}#EXID)',
            )
            .replace(
                '[Extensions]', f'{Default.EOL}[Extensions]({site}#extensions)'
            )
            .replace(
                '[Family Attribute]',
                f'[Family Attribute]({site}#family-attributes)',
            )
            .replace('[Family Event]', f'[Family Event]({site}#family-events)')
            .replace(
                '[File Path datatype]',
                f'[File Path datatype]({site}#file-path)',
            )
            .replace(
                '[Individual Attribute]',
                f'[Individual Attribute]({site}#individual-attributes)',
            )
            .replace(
                '[Individual Event]',
                f'[Individual Event]({site}#INDIVIDUAL_EVENT_STRUCTURE)',
            )
            .replace(
                '[Latter-Day Saint Ordinance]',
                f'[Latter-Day Saint Ordinance]({site}#latter-day-saint-ordinances)',
            )
            .replace('[List]', f'[List]({site}#list){Default.EOL}')
            .replace(
                '[media type]',
                f'[media type]({site}#media-type){Default.EOL}',
            )
            .replace(
                '[Removing data]',
                f'{Default.EOL}[Removing data]({site}#removing-data)',
            )
            .replace(
                '[registry of component subtags] ',
                '[registry of component subtags](https://www.iana.org/assignments/language-subtag-registry/language-subtag-registry)\n',
            )
            .replace('[RFC 3696]', f'[RFC 3696]({datatracker}3696)')
            .replace(
                f'[RFC{Default.EOL}3696]',
                f'{Default.EOL}[RFC 3696]({datatracker}3696)',
            )
            .replace(
                f'[RFC{Default.EOL}3986]',
                f'{Default.EOL}[RFC 3986]({datatracker}3986)',
            )
            .replace(
                '[RFC 3987]', f'{Default.EOL}[RFC 3987]({datatracker}3987)'
            )
            .replace('[RFC 4122]', f'[RFC 4122]({datatracker}4122)')
            .replace(
                '[RFC 5321]', f'{Default.EOL}[RFC 5321]({datatracker}5321)'
            )
            .replace(
                '[RFC 5322]', f'{Default.EOL}[RFC 5322]({datatracker}5322)'
            )
            .replace('. See also ', f'.{Default.EOL}See also ')
            .replace(
                '[The Header and Trailer]',
                f'{Default.EOL}[The Header and Trailer]({site}#the-header)',
            )
            .replace(
                '[whatwg/url]',
                f'{Default.EOL}[whatwg/url](https://url.spec.whatwg.org/)',
            )
            .replace('[YAML file format]', f'[YAML file format]({site})')
        )

    @staticmethod
    def specification(structure: dict[str, Any]) -> str:
        """Construct the Specification section of the documentation."""
        specification: list[str] = structure[Default.YAML_SPECIFICATION]
        string_linked: str = Default.EMPTY
        spec: str = """
    GEDCOM Specification:"""
        for string in specification:
            string_linked = Classes.add_links(string)
            if (
                Default.EOL not in string_linked
                and len(string_linked) > Default.LINE_LENGTH
            ):
                wrapped = wrap(
                    string_linked,
                    Default.LINE_LENGTH,
                    break_long_words=False,
                    break_on_hyphens=False,
                )
                if len(wrapped) > 1:
                    for index, line in enumerate(wrapped):
                        if index == 0:
                            spec = ''.join(
                                [spec, Default.YAML_WITH_HYPHEN, line]
                            )
                        else:
                            spec = ''.join(
                                [spec, Default.YAML_WITHOUT_HYPHEN, line]
                            )
            elif Default.EOL in string_linked:
                string_linked_split: list[str] = string_linked.split('\n')
                for line in string_linked_split:
                    if len(line) > 80:
                        line_wrapped: list[str] = wrap(
                            line,
                            75,
                            break_long_words=False,
                            break_on_hyphens=False,
                        )
                        if len(line_wrapped) > 1:
                            for index, item in enumerate(line_wrapped):
                                if index == 0:
                                    spec = ''.join(
                                        [spec, Default.YAML_WITH_HYPHEN, item]
                                    )
                                else:
                                    spec = ''.join(
                                        [
                                            spec,
                                            Default.YAML_WITHOUT_HYPHEN,
                                            item,
                                        ]
                                    )
                    else:
                        spec = ''.join(
                            [spec, Default.YAML_WITHOUT_HYPHEN, line]
                        )
            else:
                spec = ''.join([spec, Default.YAML_WITH_HYPHEN, string_linked])
        return spec

    @staticmethod
    def enumerations(
        key: str,
        full_structure: dict[str, Any],
        full_enumeration_set: dict[str, Any],
        full_enumeration: dict[str, Any],
    ) -> str:
        """Construct the Enumerations section of the documentation."""
        structure: dict[str, Any] = full_structure[key]
        enumeration_values: str = Default.EMPTY
        if (
            Default.YAML_ENUMERATION_SET in structure
            # and structure[Default.YAML_ENUMERATION_SET] != Default.EMPTY
        ):
            enum_set_key: str = Names.stem(
                structure[Default.YAML_ENUMERATION_SET]
            )
            enumeration_values = """

    Enumeration Values:"""
            for value in full_enumeration_set[enum_set_key][
                Default.YAML_ENUMERATION_VALUES
            ]:
                enum_key: str = Names.stem(value)
                enum_tag: str = Default.EMPTY
                if enum_key in full_enumeration:
                    enum_tag = full_enumeration[enum_key][
                        Default.YAML_STANDARD_TAG
                    ]
                else:
                    enum_tag = full_structure[enum_key][
                        Default.YAML_STANDARD_TAG
                    ]
                enumeration_values = ''.join(
                    [
                        enumeration_values,
                        Default.EOL,
                        Default.INDENT,
                        Default.HYPHEN,
                        Default.SPACE,
                        Default.BRACKET_LEFT,
                        enum_tag,
                        Default.BRACKET_RIGHT,
                        Default.PARENS_LEFT,
                        value,
                        Default.PARENS_RIGHT,
                    ]
                )
        return enumeration_values

    @staticmethod
    def substructures(structure: dict[str, Any]) -> str:
        """Construct the Substructures section of the documentation."""
        class_name: str = Default.EMPTY
        subs: dict[str, str] = {}
        if Default.YAML_SUBSTRUCTURES in structure:
            subs = structure[Default.YAML_SUBSTRUCTURES]
        substructures: str = Default.EMPTY
        if len(subs) > 0:
            substructures = f"""

    Substructures:{Classes.tableheader()}"""

            for subskey, value in subs.items():
                yes: str = Default.NO
                one: str = Default.MANY
                if Default.YAML_CARDINALITY_REQUIRED in value:
                    yes = Default.YES
                if Default.YAML_CARDINALITY_SINGULAR in value:
                    one = Default.ONLY_ONE
                class_name = Names.classname(
                    subskey[subskey.rfind(Default.SLASH) + 1 :]
                )
                substructures = ''.join(
                    [
                        substructures,
                        Default.EOL,
                        Default.INDENT,
                        Default.BAR,
                        Default.SPACE,
                        subskey,
                        Default.SPACE * (42 - len(subskey) + 1),
                        Default.BAR,
                        Default.SPACE,
                        one,
                        Default.SPACE * (8 - len(one) + 1),
                        Default.BAR,
                        Default.SPACE,
                        yes,
                        Default.SPACE * (8 - len(yes) + 1),
                        Default.BAR,
                        Default.SPACE,
                        class_name,
                        Default.SPACE * (12 - len(class_name) + 1),
                        Default.BAR,
                        Default.SPACE,
                    ]
                )
        return substructures

    @staticmethod
    def superstructures(structure: dict[str, Any]) -> str:
        """Construct the Substructures section of the documentation."""
        class_name: str = Default.EMPTY
        supers: dict[str, str] = {}
        if Default.YAML_SUPERSTRUCTURES in structure:
            supers = structure[Default.YAML_SUPERSTRUCTURES]
        superstructures: str = Default.EMPTY
        if len(supers) > 0:
            superstructures = f"""

    Superstructures:{Classes.tableheader()}"""
            for superskey, value in supers.items():
                yes: str = Default.NO
                one: str = Default.MANY
                if Default.YAML_CARDINALITY_REQUIRED in value:
                    yes = Default.YES
                if Default.YAML_CARDINALITY_SINGULAR in value:
                    one = Default.ONLY_ONE
                class_name = Names.classname(
                    superskey[superskey.rfind(Default.SLASH) + 1 :]
                )
                superstructures = ''.join(
                    [
                        superstructures,
                        Default.EOL,
                        Default.INDENT,
                        Default.BAR,
                        Default.SPACE,
                        superskey,
                        Default.SPACE * (42 - len(superskey) + 1),
                        Default.BAR,
                        Default.SPACE,
                        one,
                        Default.SPACE * (8 - len(one) + 1),
                        Default.BAR,
                        Default.SPACE,
                        yes,
                        Default.SPACE * (8 - len(yes) + 1),
                        Default.BAR,
                        Default.SPACE,
                        class_name,
                        Default.SPACE * (12 - len(class_name) + 1),
                        Default.BAR,
                    ]
                )
        return superstructures

    @staticmethod
    def value_of(structure: dict[str, Any]) -> str:
        """Construct the Enumerations section of the documentation."""
        value_of: str = Default.EMPTY
        if Default.YAML_VALUE_OF in structure:
            value_of = """

    Enumeration Value Of:"""
            for value in structure[Default.YAML_VALUE_OF]:
                value_of = f'{value_of}{Default.EOL}{Default.INDENT}{Default.HYPHEN} {value}'
        return value_of

    @staticmethod
    def arguments(key: str, structure: dict[str, Any]) -> str:
        """Construct the Args section of the documentation."""
        args = """
        
    Args:"""
        if (
            Default.YAML_PAYLOAD in structure
            and structure[Default.YAML_PAYLOAD] is not None
            and key[0:6] != Default.RECORD
        ):
            args = ''.join(
                [
                    args,
                    Default.EOL,
                    Default.INDENT * 2,
                    Default.CODE_VALUE,
                    ': A value of data type ',
                    structure[Default.YAML_PAYLOAD],
                ]
            )
        if key[0:6] == Default.RECORD:
            args = ''.join(
                [
                    args,
                    Default.EOL,
                    Default.INDENT * 2,
                    Default.CODE_VALUE,
                    ': A value of data type ',
                    Classes.get_record_datatype(key),
                ]
            )
        return ''.join(
            [
                args,
                Default.EOL,
                Default.INDENT * 2,
                Default.CODE_SUBS,
                ': A permitted substructure or list of permitted substructures.',
            ]
        )

    @staticmethod
    def references(structure: dict[str, Any]) -> str:
        """Construct the References section of the documentation."""
        uri = structure[Default.YAML_URI]
        tag = structure[Default.YAML_STANDARD_TAG]
        return f"""

    References:
    - [GEDCOM {tag} Structure]({uri})
    - [GEDCOM Specifications](https://gedcom.io/specifications/FamilySearchGEDCOMv{Config.VERSION}.html)"""

    @staticmethod
    def get_datatype(structure: dict[str, Any]) -> str:
        """Convert the GEDCOM datatype into python datatype."""
        datatype: str = Default.EMPTY
        if Default.YAML_PAYLOAD in structure and structure is not None:
            datatype = structure[Default.YAML_PAYLOAD]
        match datatype:
            case 'http://www.w3.org/2001/XMLSchema#nonNegativeInteger':
                return 'int'
            case '@<https://gedcom.io/terms/v7/record-INDI>@':
                return Default.XREF_INDIVIDUAL
            case '@<https://gedcom.io/terms/v7/record-FAM>@':
                return Default.XREF_FAMILY
            case '@<https://gedcom.io/terms/v7/record-SUBM>@':
                return Default.XREF_SUBMITTER
            case '@<https://gedcom.io/terms/v7/record-OBJE>@':
                return Default.XREF_MULTIMEDIA
            case '@<https://gedcom.io/terms/v7/record-REPO>@':
                return Default.XREF_REPOSITORY
            case '@<https://gedcom.io/terms/v7/record-SNOTE>@':
                return Default.XREF_SHARED_NOTE
            case '@<https://gedcom.io/terms/v7/record-SOUR>@':
                return Default.XREF_SOURCE
            case _:
                return 'str'

    @staticmethod
    def get_record_datatype(key: str) -> str:
        """Assign a cross reference datatype to specific records."""
        datatype: str = key[7:]
        result: str = Default.EMPTY
        match datatype:
            case Default.TAG_FAM:
                result = Default.XREF_FAMILY
            case Default.TAG_INDI:
                result = Default.XREF_INDIVIDUAL
            case Default.TAG_OBJE:
                result = Default.XREF_MULTIMEDIA
            case Default.TAG_REPO:
                result = Default.XREF_REPOSITORY
            case Default.TAG_SNOTE:
                result = Default.XREF_SHARED_NOTE
            case Default.TAG_SOUR:
                result = Default.XREF_SOURCE
            case Default.TAG_SUBM:
                result = Default.XREF_SUBMITTER
        return result

    @staticmethod
    def init(
        key: str,
        full_structure: dict[str, Any],
        full_enumeration_set: dict[str, dict[str, Any]],
        full_enumeration: dict[str, dict[str, Any]],
    ) -> str:
        """Construct the global constants and init section of the class."""
        tag: str = full_structure[key][Default.YAML_STANDARD_TAG]
        required: list[str] = []
        single: list[str] = []
        permitted: list[str] = []
        enum_tags: list[str] = []
        enum_set_key: str = Default.EMPTY
        enum_key: str = Default.EMPTY
        if Default.YAML_ENUMERATION_SET in full_structure[key]:
            enum_set_key = Names.stem(
                full_structure[key][Default.YAML_ENUMERATION_SET]
            )
            for enum in full_enumeration_set[enum_set_key][
                Default.YAML_ENUMERATION_VALUES
            ]:
                enum_key = Names.stem(enum)
                if enum_key in full_enumeration:
                    enum_tags.append(
                        full_enumeration[enum_key][Default.YAML_STANDARD_TAG]
                    )
                else:
                    enum_tags.append(
                        full_structure[enum_key][Default.YAML_STANDARD_TAG]
                    )
        if Default.YAML_SUBSTRUCTURES in full_structure[key]:
            for uri, cardinality in full_structure[key][
                Default.YAML_SUBSTRUCTURES
            ].items():
                class_name: str = Names.classname(uri)
                permitted.append(class_name)
                if Default.YAML_CARDINALITY_REQUIRED in cardinality:
                    required.append(class_name)
                if Default.YAML_CARDINALITY_SINGULAR in cardinality:
                    single.append(class_name)
        value_arg: str = f', {Default.CODE_VALUE}: {Classes.get_datatype(full_structure[key])}'
        value_init: str = Default.CODE_VALUE
        subs_arg: str = f', {Default.CODE_SUBS}: Any'
        if len(required) == 0:
            subs_arg = f', {Default.CODE_SUBS}: Any = None'
        subs_init: str = Default.CODE_SUBS
        payload: str = Default.EMPTY
        if (
            Default.YAML_PAYLOAD in full_structure[key]
            and full_structure[key][Default.YAML_PAYLOAD] is not None
        ):
            payload = full_structure[key][Default.YAML_PAYLOAD]
        if payload == Default.EMPTY or key == 'record-SNOTE':
            value_arg = Default.EMPTY
            value_init = 'None'
            if 'record-' in key:
                value_arg = f', {Default.CODE_VALUE}: {Classes.get_record_datatype(key)}'
                value_init = Default.CODE_VALUE
        deprecation_line: str = Default.EMPTY
        if key in ['ADR1', 'ADR2', 'ADR3']:
            deprecation_line = f'{Default.EOL}        logging.info(Msg.DEPRECATION_WARNING.format(self.class_name))'
        init_line: str = f"""
    def __init__(self{value_arg}{subs_arg}) -> None:
        super().__init__(
            value={value_init}, 
            subs={subs_init}, 
            key='{key}',
            tag='{tag}',
            permitted={permitted},
            required={required},
            single={single},
            enum_key='{enum_key}',
            enum_tags={enum_tags},
            payload='{full_structure[key][Default.YAML_PAYLOAD]}',
            class_name='{Names.classname(key)}',
        ){deprecation_line}"""
        return init_line #''.join([init, init_line])

    @staticmethod
    def generate_class(
        key: str,
        full_structure: dict[str, Any],
        full_enumeration_set: dict[str, Any],
        full_enumeration: dict[str, Any],
        examples: str,
    ) -> str:
        """Generate a single class and its documentation defined by its Structure definition.

        Examples:
            If we have the structure and enumeration set dictionaries constructed in a specs.py file,
            we can use them to build a string that represents the class in the classes module.
            >>> from genedata.examples import Examples7
            >>> from genedata.load import Classes
            >>> from genedata.specifications7 import (
            ...     Structure,
            ...     EnumerationSet,
            ...     Enumeration,
            ... )
            >>> map = Classes.generate_class(
            ...     'MAP',
            ...     Structure,
            ...     EnumerationSet,
            ...     Enumeration,
            ...     Examples7['MAP'],
            ... )

        Args:
            key: The key of the Structure dictionary.
            structure: The structure dictionary where GEDCOM structure specifications are found.
            enumerationset: The enumerationset dictionary where GEDCOM enumeration-set
                specifications are found.
            examples: The dictionary of examples to add to this class.
        """
        tag: str = full_structure[key][Default.YAML_STANDARD_TAG]
        class_name: str = Names.classname(key)
        parts: str = ''.join(
            [
                Classes.specification(full_structure[key]),
                examples,
                Classes.substructures(full_structure[key]),
                Classes.superstructures(full_structure[key]),
                Classes.enumerations(
                    key, full_structure, full_enumeration_set, full_enumeration
                ),
                Classes.value_of(full_structure[key]),
                Classes.arguments(key, full_structure[key]),
                Classes.references(full_structure[key]),
            ]
        )
        lines: str = f"""

class {class_name}(BaseStructure):
    '''Store, validate and format the {tag} structure. 
    
    This class was generated by `{__class__.__name__}` from the `{__name__}` module
    using GEDCOM yaml specification files.  Links were added to the specification 
    and tables constructed from the yaml files to aid the user of these classes. 

    DO NOT CHANGE THIS CLASS MANUALLY.  

    {parts}
    '''
    {Classes.init(key, full_structure, full_enumeration_set, full_enumeration)}
    """
        return lines

    @staticmethod
    def all_classes(
        full_structure: dict[str, dict[str, Any]],
        full_enumeration_set: dict[str, dict[str, Any]],
        full_enumeration: dict[str, dict[str, Any]],
        full_examples: dict[str, str],
    ) -> str:
        """Generate all classes and their documentation defined by the Structure dictionary."""

        lines: str = Default.EMPTY
        for key, _structure in full_structure.items():
            if key not in [Default.CONT, Default.TRLR]:
                examples: str = Default.EMPTY
                if key in full_examples:
                    examples = full_examples[key]
                lines = ''.join(
                    [
                        lines,
                        Classes.generate_class(
                            key,
                            full_structure,
                            full_enumeration_set,
                            full_enumeration,
                            examples,
                        ),
                    ]
                )
        return lines

    @staticmethod
    def build_all(
        source: str,
        version: str,
        full_structure: dict[str, dict[str, Any]],
        full_enumeration_set: dict[str, dict[str, Any]],
        full_enumeration: dict[str, dict[str, Any]],
        full_examples: dict[str, str],
    ) -> str:
        """Construct the entire module containing GEDCOM structures converted to classes.

        To build the classes module one either needs a base directory where the yaml files
        are stored, a base url or a specs module that has already been build.  From the
        specs module one will need the Structure and EnumerationSet dictionaries.

        Example:
            This example constructs a string that could be used for a classes module
            using a specification module that has already been constructed.
            >>> from genedata.examples import Examples7
            >>> from genedata.load import Classes
            >>> from genedata.specifications7 import (
            ...     Structure,
            ...     EnumerationSet,
            ...     Enumeration,
            ... )
            >>> all = Classes.build_all(
            ...     'specify-ged-source',
            ...     '7.0',
            ...     Structure,
            ...     EnumerationSet,
            ...     Enumeration,
            ...     Examples7,
            ... )

        """
        return ''.join(
            [
                Classes.preamble(source, version),
                Classes.all_listing(full_structure),
                Classes.imports(),
                Classes.all_classes(
                    full_structure,
                    full_enumeration_set,
                    full_enumeration,
                    full_examples,
                ),
            ]
        )


class Tests:
    """Generate pytest modules for testing the classes."""

    @staticmethod
    def get_enum(
        key: str,
        structures: dict[str, dict[str, Any]],
        enumerationsets: dict[str, dict[str, Any]],
        enumerations: dict[str, dict[str, Any]],
    ) -> str:
        if Default.YAML_ENUMERATION_SET in structures[key]:
            enum_set_key = Names.keyname(
                structures[key][Default.YAML_ENUMERATION_SET]
            )
            enum_value = enumerationsets[enum_set_key][
                Default.YAML_ENUMERATION_VALUES
            ][0]
            enum_key = Names.keyname(enum_value)
            if enum_key in enumerations:
                return str(enumerations[enum_key][Default.YAML_STANDARD_TAG])
            return str(structures[enum_key][Default.YAML_STANDARD_TAG])
        return Default.EMPTY

    @staticmethod
    def get_value(
        key: str,
        structures: dict[str, dict[str, Any]],
        enumerationsets: dict[str, dict[str, Any]],
        enumerations: dict[str, dict[str, Any]],
        y: bool = True,
    ) -> str:
        enum: str = Tests.get_enum(
            key, structures, enumerationsets, enumerations
        )
        payload: str = structures[key][Default.YAML_PAYLOAD]
        match payload:
            case 'http://www.w3.org/2001/XMLSchema#string':
                match key:
                    case 'LATI':
                        return "'N10.1'"
                    case 'LONG':
                        return "'E10.1'"
                    case 'record-SNOTE':
                        return 'snote'
                    case _:
                        return "'abc'"
            case 'Y|<NULL>':
                if y:
                    return "'Y'"
                return "''"
            case 'None':
                match key:
                    case 'record-FAM':
                        return 'fam'
                    case 'record-INDI':
                        return 'indi'
                    case 'record-OBJE':
                        return 'obje'
                    case 'record-REPO':
                        return 'repo'
                    case 'record-SOUR':
                        return 'sour'
                    case 'record-SUBM':
                        return 'subm'
            case 'https://gedcom.io/terms/v7/type-Enum':
                return f"'{enum}'"
            case 'http://www.w3.org/2001/XMLSchema#nonNegativeInteger':
                return '1'
            case '@<https://gedcom.io/terms/v7/record-FAM>@':
                return 'fam'
            case '@<https://gedcom.io/terms/v7/record-INDI>@':
                return 'indi'
            case '@<https://gedcom.io/terms/v7/record-SUBM>@':
                return 'subm'
            case 'https://gedcom.io/terms/v7/type-List#Text':
                return "'text'"
            case 'http://www.w3.org/2001/XMLSchema#Language':
                return "'en-US'"
            case 'https://gedcom.io/terms/v7/type-Date#period':
                return "'FROM 1 JAN 2000 TO 1 JAN 2001'"
            case 'https://gedcom.io/terms/v7/type-List#Enum':
                return f"'{enum}'"
            case 'https://gedcom.io/terms/v7/type-Date#exact':
                return "'1 JAN 2000'"
            case 'https://gedcom.io/terms/v7/type-Date':
                return "'1 JAN 2000'"
            case 'https://gedcom.io/terms/v7/type-FilePath':
                return "'dir/to/somewhere/'"
            case 'http://www.w3.org/ns/dcat#mediaType':
                return "'text/html'"
            case 'https://gedcom.io/terms/v7/type-Name':
                return "'John /Doe/'"
            case 'https://gedcom.io/terms/v7/type-Age':
                return "'> 10y 2m 1d'"
            case '@<https://gedcom.io/terms/v7/record-OBJE>@':
                return 'obje'
            case '@<https://gedcom.io/terms/v7/record-REPO>@':
                return 'repo'
            case '@<https://gedcom.io/terms/v7/record-SNOTE>@':
                return 'snote'
            case '@<https://gedcom.io/terms/v7/record-SOUR>@':
                return 'sour'
            case 'https://gedcom.io/terms/v7/type-Time':
                return "'12:12:12'"
            case _:
                return Default.EMPTY
        return Default.EMPTY

    @staticmethod
    def there_are_required_substructures(substructures: dict[str, str]) -> bool:
        """Return true if there dictionary of substructures contains a required substructure.

        Args:
            substructures: The subdictionary of Structure containing the uri as key
                and its cardinality code as value.  The cardinality code `{1:`
                signals a required substructure.
        """
        for _key, cardinality in substructures.items():
            if Default.CARDINALITY_REQUIRED in cardinality:
                return True
        return False

    @staticmethod
    def preamble(test: str) -> str:
        """Construct a document to describe a module containing a set of tests."""
        return f"""'''This module contains {test} tests to be run with pytest.

The file was generated by methods of the `{__class__.__name__}` class in the `{__name__}` module.

DO NOT MODIFY THIS FILE.
'''

from genedata.build import Genealogy   # noqa: I001
import genedata.classes{Config.VERSION} as {Default.CODE_CLASS}


{Default.CODE_GENEALOGY} = Genealogy('test')
fam = {Default.CODE_GENEALOGY}.family_xref('1')
indi = {Default.CODE_GENEALOGY}.individual_xref('1')
obje = {Default.CODE_GENEALOGY}.multimedia_xref('1')
repo = {Default.CODE_GENEALOGY}.repository_xref('1')
snote = {Default.CODE_GENEALOGY}.shared_note_xref('1', 'a note')
sour = {Default.CODE_GENEALOGY}.source_xref('1')
subm = {Default.CODE_GENEALOGY}.submitter_xref('1')
"""

    @staticmethod
    def value(
        structures: dict[str, dict[str, Any]],
        enumerationsets: dict[str, dict[str, Any]],
        enumerations: dict[str, dict[str, Any]],
    ) -> str:
        """Construct the set of all value tests.

        The structures tested do not have any required substructures so that
        only a value need be displayed with them.  All tests are expected to pass
        the validation process in the BaseStructure class.

        Args:
            structures: The full Structure dictionary containing all structures.
            enumerationsets: The full EnumerationSet dictionary containing all structures.
            enumerations: The full Enumeration dictionary containing the enumerations.
        """

        def write(key: str, value: str) -> str:
            """Write out a single test for class `key` with value `value`."""
            class_name: str = Names.classname(key)
            lines: str = f"""

def test_{test_name.lower().replace(Default.SPACE, Default.UNDERLINE)}_{class_name}() -> None:
    '''Validate the `{class_name}` structure with a value, but without substructures.'''
    m = {Default.CODE_CLASS}.{class_name}({value})
    assert m.validate()
"""
            return lines

        test_name: str = 'Value'
        lines: str = Tests.preamble(test_name)
        value: str = Default.EMPTY
        for key, structure in structures.items():
            if not Tests.there_are_required_substructures(
                structure[Default.YAML_SUBSTRUCTURES]
            ):
                value = Tests.get_value(
                    key,
                    structures,
                    enumerationsets,
                    enumerations,
                )
                if value != Default.EMPTY:
                    lines = ''.join([lines, write(key, value)])
        return lines
