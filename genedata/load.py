# load.py
"""Load a version of the GEDCOM specifications into python dictionaries,
generate classes from the loaded specifications and generate test modules for those classes.

"""

__all__ = [
    'Classes',
    'Specs',
    'Tests',
]

from pathlib import Path
from textwrap import wrap
from typing import Any

from genedata.constants import Config, Default
from genedata.messages import Msg
from genedata.methods import Names, Util


class Classes:
    """Methods to construct classes from the GEDCOM specification."""

    @staticmethod
    def preamble(source: str, version: str) -> str:
        return f"""'''This module of classes was generated by methods in the `{__class__.__name__}` class
of the `{__name__}` module from GEDCOM yaml specification files.  

DO NOT MANUALLY MODIFY THIS MODULE.

The specifications for this module are from the 
[GEDCOM files]({source}) for version {version}.
'''

"""

    @staticmethod
    def tableheader() -> str:
        return """
    |               Specification                | Quantity | Required |  Class Name  |
    | ------------------------------------------ | -------- | -------- | ------------ |"""

    @staticmethod
    def generate__all__(
        structure: dict[str, dict[str, Any]],
    ) -> str:
        """Generate the __all__ = [] by filling in the list with the modified keys from Structure."""
        count: int = 0
        lines: str = '__all__ = [    # noqa: RUF022'
        for key in structure:
            lines = f"{lines}{Default.EOL}{Default.INDENT}'{Names.classname(key)}'{Default.COMMA}"
            count += 1
        if count == 0:
            return Default.EMPTY
        return f'{lines}{Default.EOL}]{Default.EOL}'

    @staticmethod
    def generate_imports() -> str:
        return f"""
import logging
from typing import Any

from genedata.messages import Msg
from genedata.structure import (
    BaseStructure,
    {Default.XREF_FAMILY},
    {Default.XREF_INDIVIDUAL},
    {Default.XREF_MULTIMEDIA},
    {Default.XREF_REPOSITORY},
    {Default.XREF_SHARED_NOTE},
    {Default.XREF_SOURCE},
    {Default.XREF_SUBMITTER},
)
"""

    @staticmethod
    def add_links(text: str) -> str:
        """Add links missing in the specifications to text with brackets around it."""
        site: str = f'https://gedcom.io/specifications/FamilySearchGEDCOMv{Config.VERSION}.html'
        datatracker: str = 'https://datatracker.ietf.org/doc/html/rfc'
        return (
            text.replace(
                '[BCP 47]',
                f'{Default.EOL}[BCP 47](https://en.wikipedia.org/wiki/IETF_language_tag)',
            )
            .replace(
                '[documented extension tag]',
                f'[documented extension tag]({site}#extension-tags)',
            )
            .replace('[E.123]', '[E.123](https://en.wikipedia.org/wiki/E.123)')
            .replace(
                '[E.164]',
                f'{Default.EOL}[E.164](https://en.wikipedia.org/wiki/E.164)',
            )
            .replace(
                '[exid-types registry]',
                f'{Default.EOL}[exid-types registry]({site}#EXID)',
            )
            .replace(
                '[Extensions]', f'{Default.EOL}[Extensions]({site}#extensions)'
            )
            .replace(
                '[Family Attribute]',
                f'[Family Attribute]({site}#family-attributes)',
            )
            .replace('[Family Event]', f'[Family Event]({site}#family-events)')
            .replace(
                '[File Path datatype]',
                f'[File Path datatype]({site}#file-path)',
            )
            .replace(
                '[Individual Attribute]',
                f'[Individual Attribute]({site}#individual-attributes)',
            )
            .replace(
                '[Individual Event]',
                f'[Individual Event]({site}#INDIVIDUAL_EVENT_STRUCTURE)',
            )
            .replace(
                '[Latter-Day Saint Ordinance]',
                f'[Latter-Day Saint Ordinance]({site}#latter-day-saint-ordinances)',
            )
            .replace('[List]', f'[List]({site}#list){Default.EOL}')
            .replace(
                '[media type]',
                f'[media type]({site}#media-type){Default.EOL}',
            )
            .replace(
                '[Removing data]',
                f'{Default.EOL}[Removing data]({site}#removing-data)',
            )
            .replace(
                '[registry of component subtags] ',
                '[registry of component subtags](https://www.iana.org/assignments/language-subtag-registry/language-subtag-registry)\n',
            )
            .replace('[RFC 3696]', f'[RFC 3696]({datatracker}3696)')
            .replace(
                f'[RFC{Default.EOL}3696]',
                f'{Default.EOL}[RFC 3696]({datatracker}3696)',
            )
            .replace(
                f'[RFC{Default.EOL}3986]',
                f'{Default.EOL}[RFC 3986]({datatracker}3986)',
            )
            .replace(
                '[RFC 3987]', f'{Default.EOL}[RFC 3987]({datatracker}3987)'
            )
            .replace('[RFC 4122]', f'[RFC 4122]({datatracker}4122)')
            .replace(
                '[RFC 5321]', f'{Default.EOL}[RFC 5321]({datatracker}5321)'
            )
            .replace(
                '[RFC 5322]', f'{Default.EOL}[RFC 5322]({datatracker}5322)'
            )
            .replace('. See also ', f'.{Default.EOL}See also ')
            .replace(
                '[The Header and Trailer]',
                f'{Default.EOL}[The Header and Trailer]({site}#the-header)',
            )
            .replace(
                '[whatwg/url]',
                f'{Default.EOL}[whatwg/url](https://url.spec.whatwg.org/)',
            )
            .replace('[YAML file format]', f'[YAML file format]({site})')
        )

    @staticmethod
    def generate_specification(key: str, structure: dict[str, Any]) -> str:
        """Construct the Specification section of the documentation."""
        specification: list[str] = structure[key][Default.YAML_SPECIFICATION]
        string_linked: str = Default.EMPTY
        spec: str = """
    GEDCOM Specification:"""
        for string in specification:
            string_linked = Classes.add_links(string)
            if (
                Default.EOL not in string_linked
                and len(string_linked) > Default.LINE_LENGTH
            ):
                wrapped = wrap(
                    string_linked,
                    Default.LINE_LENGTH,
                    break_long_words=False,
                    break_on_hyphens=False,
                )
                if len(wrapped) > 1:
                    for index, line in enumerate(wrapped):
                        if index == 0:
                            spec = ''.join(
                                [spec, Default.YAML_WITH_HYPHEN, line]
                            )
                        else:
                            spec = ''.join(
                                [spec, Default.YAML_WITHOUT_HYPHEN, line]
                            )
            elif Default.EOL in string_linked:
                string_linked_split: list[str] = string_linked.split('\n')
                for line in string_linked_split:
                    if len(line) > 80:
                        line_wrapped: list[str] = wrap(
                            line,
                            75,
                            break_long_words=False,
                            break_on_hyphens=False,
                        )
                        if len(line_wrapped) > 1:
                            for index, item in enumerate(line_wrapped):
                                if index == 0:
                                    spec = ''.join(
                                        [spec, Default.YAML_WITH_HYPHEN, item]
                                    )
                                else:
                                    spec = ''.join(
                                        [
                                            spec,
                                            Default.YAML_WITHOUT_HYPHEN,
                                            item,
                                        ]
                                    )
                    else:
                        spec = ''.join(
                            [spec, Default.YAML_WITHOUT_HYPHEN, line]
                        )
            else:
                spec = ''.join([spec, Default.YAML_WITH_HYPHEN, string_linked])
        return spec

    @staticmethod
    def generate_examples(key: str, examples: dict[str, str]) -> str:
        """Construct the Example section from the Examples dictionary in gedcom7."""
        example: str = Default.EMPTY
        if key in examples:
            example = examples[key]
        return example

    @staticmethod
    def generate_enumerations(
        key: str, structure: dict[str, Any], enumerationset: dict[str, Any]
    ) -> str:
        """Construct the Enumerations section of the documentation."""
        enumeration_values: str = Default.EMPTY
        if (
            Default.YAML_ENUMERATION_SET in structure[key]
            and structure[key][Default.YAML_ENUM_KEY] != Default.EMPTY
        ):
            enum_key: str = structure[key][Default.YAML_ENUM_KEY]
            enumeration_values = """

    Enumeration Values:"""
            for value in enumerationset[enum_key][
                Default.YAML_ENUMERATION_VALUES
            ]:
                enumeration_values = ''.join(
                    [
                        enumeration_values,
                        Default.EOL,
                        Default.INDENT,
                        Default.HYPHEN,
                        Default.SPACE,
                        Default.BRACKET_LEFT,
                        Specs.get_enum_tag(value),
                        Default.BRACKET_RIGHT,
                        Default.PARENS_LEFT,
                        value,
                        Default.PARENS_RIGHT,
                    ]
                )
        return enumeration_values

    @staticmethod
    def generate_substructures(key: str, structure: dict[str, Any]) -> str:
        """Construct the Substructures section of the documentation."""
        class_name: str = Default.EMPTY
        subs: dict[str, str] = {}
        if Default.YAML_SUBSTRUCTURES in structure[key]:
            subs = structure[key][Default.YAML_SUBSTRUCTURES]
        substructures: str = Default.EMPTY
        if len(subs) > 0:
            substructures = f"""

    Substructures:{Classes.tableheader()}"""

            for subskey, value in subs.items():
                yes: str = Default.NO
                one: str = Default.MANY
                if Default.YAML_CARDINALITY_REQUIRED in value:
                    yes = Default.YES
                if Default.YAML_CARDINALITY_SINGULAR in value:
                    one = Default.ONLY_ONE
                class_name = Names.classname(
                    subskey[subskey.rfind(Default.SLASH) + 1 :]
                )
                substructures = ''.join(
                    [
                        substructures,
                        Default.EOL,
                        Default.INDENT,
                        Default.BAR,
                        Default.SPACE,
                        subskey,
                        Default.SPACE * (42 - len(subskey) + 1),
                        Default.BAR,
                        Default.SPACE,
                        one,
                        Default.SPACE * (8 - len(one) + 1),
                        Default.BAR,
                        Default.SPACE,
                        yes,
                        Default.SPACE * (8 - len(yes) + 1),
                        Default.BAR,
                        Default.SPACE,
                        class_name,
                        Default.SPACE * (12 - len(class_name) + 1),
                        Default.BAR,
                        Default.SPACE,
                    ]
                )
        return substructures

    @staticmethod
    def generate_superstructures(key: str, structure: dict[str, Any]) -> str:
        """Construct the Substructures section of the documentation."""
        class_name: str = Default.EMPTY
        supers: dict[str, str] = {}
        if Default.YAML_SUPERSTRUCTURES in structure[key]:
            supers = structure[key][Default.YAML_SUPERSTRUCTURES]
        superstructures: str = Default.EMPTY
        if len(supers) > 0:
            superstructures = f"""

    Superstructures:{Classes.tableheader()}"""
            for superskey, value in supers.items():
                yes: str = Default.NO
                one: str = Default.MANY
                if Default.YAML_CARDINALITY_REQUIRED in value:
                    yes = Default.YES
                if Default.YAML_CARDINALITY_SINGULAR in value:
                    one = Default.ONLY_ONE
                class_name = Names.classname(
                    superskey[superskey.rfind(Default.SLASH) + 1 :]
                )
                superstructures = ''.join(
                    [
                        superstructures,
                        Default.EOL,
                        Default.INDENT,
                        Default.BAR,
                        Default.SPACE,
                        superskey,
                        Default.SPACE * (42 - len(superskey) + 1),
                        Default.BAR,
                        Default.SPACE,
                        one,
                        Default.SPACE * (8 - len(one) + 1),
                        Default.BAR,
                        Default.SPACE,
                        yes,
                        Default.SPACE * (8 - len(yes) + 1),
                        Default.BAR,
                        Default.SPACE,
                        class_name,
                        Default.SPACE * (12 - len(class_name) + 1),
                        Default.BAR,
                    ]
                )
        return superstructures

    @staticmethod
    def generate_value_of(key: str, structure: dict[str, Any]) -> str:
        """Construct the Enumerations section of the documentation."""
        value_of: str = Default.EMPTY
        if Default.YAML_VALUE_OF in structure[key]:
            value_of = """

    Enumeration Value Of:"""
            for value in structure[key][Default.YAML_VALUE_OF]:
                value_of = f'{value_of}{Default.EOL}{Default.INDENT}{Default.HYPHEN} {value}'
        return value_of

    @staticmethod
    def generate_args(key: str, structure: dict[str, Any]) -> str:
        """Construct the Args section of the documentation."""
        args = """
        
    Args:"""
        if (
            Default.YAML_PAYLOAD in structure[key]
            and structure[key][Default.YAML_PAYLOAD] is not None
            and key[0:6] != Default.RECORD
        ):
            args = ''.join(
                [
                    args,
                    Default.EOL,
                    Default.INDENT * 2,
                    Default.CODE_VALUE,
                    ': A value of data type ',
                    structure[key][Default.YAML_PAYLOAD],
                ]
            )
        if key[0:6] == Default.RECORD:
            args = ''.join(
                [
                    args,
                    Default.EOL,
                    Default.INDENT * 2,
                    Default.CODE_VALUE,
                    ': A value of data type ',
                    Classes.get_record_datatype(key),
                ]
            )
        return ''.join(
            [
                args,
                Default.EOL,
                Default.INDENT * 2,
                Default.CODE_SUBS,
                ': A permitted substructure or list of permitted substructures.',
            ]
        )

    @staticmethod
    def generate_references(key: str, structure: dict[str, Any]) -> str:
        """Construct the References section of the documentation."""
        uri = structure[key][Default.YAML_URI]
        tag = structure[key][Default.YAML_STANDARD_TAG]
        return f"""

    References:
    - [GEDCOM {tag} Structure]({uri})
    - [GEDCOM Specifications](https://gedcom.io/specifications/FamilySearchGEDCOMv{Config.VERSION}.html)"""

    @staticmethod
    def get_datatype(key: str, structure: dict[str, Any]) -> str:
        """Convert the GEDCOM datatype into python datatype."""
        datatype: str = Default.EMPTY
        if (
            Default.YAML_PAYLOAD in structure[key]
            and structure[key] is not None
        ):
            datatype = structure[key][Default.YAML_PAYLOAD]
        match datatype:
            case 'http://www.w3.org/2001/XMLSchema#nonNegativeInteger':
                return 'int'
            case '@<https://gedcom.io/terms/v7/record-INDI>@':
                return Default.XREF_INDIVIDUAL
            case '@<https://gedcom.io/terms/v7/record-FAM>@':
                return Default.XREF_FAMILY
            case '@<https://gedcom.io/terms/v7/record-SUBM>@':
                return Default.XREF_SUBMITTER
            case '@<https://gedcom.io/terms/v7/record-OBJE>@':
                return Default.XREF_MULTIMEDIA
            case '@<https://gedcom.io/terms/v7/record-REPO>@':
                return Default.XREF_REPOSITORY
            case '@<https://gedcom.io/terms/v7/record-SNOTE>@':
                return Default.XREF_SHARED_NOTE
            case '@<https://gedcom.io/terms/v7/record-SOUR>@':
                return Default.XREF_SOURCE
            case _:
                return 'str'

    @staticmethod
    def get_record_datatype(key: str) -> str:
        """Assign a cross reference datatype to specific records."""
        datatype: str = key[7:]
        result: str = Default.EMPTY
        match datatype:
            case Default.TAG_FAM:
                result = Default.XREF_FAMILY
            case Default.TAG_INDI:
                result = Default.XREF_INDIVIDUAL
            case Default.TAG_OBJE:
                result = Default.XREF_MULTIMEDIA
            case Default.TAG_REPO:
                result = Default.XREF_REPOSITORY
            case Default.TAG_SNOTE:
                result = Default.XREF_SHARED_NOTE
            case Default.TAG_SOUR:
                result = Default.XREF_SOURCE
            case Default.TAG_SUBM:
                result = Default.XREF_SUBMITTER
        return result

    @staticmethod
    def generate_init(key: str, structure: dict[str, Any]) -> str:
        """Construct the global constants and init section of the class."""
        required: list[str] = structure[key][Default.YAML_REQUIRED]
        value_arg: str = (
            f', {Default.CODE_VALUE}: {Classes.get_datatype(key, structure)}'
        )
        value_init: str = Default.CODE_VALUE
        subs_arg: str = f', {Default.CODE_SUBS}: Any'
        if len(required) == 0:
            subs_arg = f', {Default.CODE_SUBS}: Any = None'
        subs_init: str = Default.CODE_SUBS
        payload: str = Default.EMPTY
        if (
            Default.YAML_PAYLOAD in structure[key]
            and structure[key][Default.YAML_PAYLOAD] is not None
        ):
            payload = structure[key][Default.YAML_PAYLOAD]
        init: str = f"{Default.EOL}    key: str = '{key}'"
        if payload == Default.EMPTY or key == 'record-SNOTE':
            value_arg = Default.EMPTY
            value_init = 'None'
            if 'record-' in key:
                init = f"{Default.EOL}    key: str = '{key}'"
                value_arg = f', {Default.CODE_VALUE}: {Classes.get_record_datatype(key)}'
                value_init = Default.CODE_VALUE
        deprecation_line: str = Default.EMPTY
        if key in ['ADR1', 'ADR2', 'ADR3']:
            deprecation_line = f'{Default.EOL}        logging.info(Msg.DEPRECATION_WARNING.format(self.class_name))'
        init_line: str = f"""
        
    def __init__(self{value_arg}{subs_arg}) -> None:
        super().__init__({value_init}, {subs_init}, self.key){deprecation_line}"""
        return ''.join([init, init_line])

    @staticmethod
    def generate_class(
        key: str,
        structure: dict[str, Any],
        enumerationset: dict[str, Any],
        examples: dict[str, str],
    ) -> str:
        """Generate a single class and its documentation defined by its Structure definition.

        Examples:
            If we have the structure and enumeration set dictionaries constructed in a specs.py file,
            we can use them to build a string that represents the class in the classes module.
            >>> from genedata.prep import Construct
            >>> from genedata.specs7 import Structure, EnumerationSet
            >>> map = Construct.generate_class(
            ...     'MAP', '', Structure, EnumerationSet
            ... )

            If one doesn't have a specs module one will need a base directory where the
            yaml files are stored.  The test directory is 'tests/prep_test/gedtest' which
            will be used here.
            >>> map2 = Construct.generate_class(
            ...     'MAP', 'tests/prep_test/gedtest'
            ... )

            However, without either the url or the dictionaries passed to thie method,
            it will through a ValueError.
            >>> map3 = Construct.generate_class('MAP')
            Traceback (most recent call last):
            ValueError: Missing both a url and specification dictionaries.

        Args:
            key: The key of the Structure dictionary.
            url: The source of the yaml files where one can read the structure and enumeration dictionaries.
            structure_dictionary: The structure dictionary as an alternative to using the url to get this.
            enumeration_dictionary: The enumeration dictionary as an alternative to using the url to get this.
        """
        tag: str = structure[key][Default.YAML_STANDARD_TAG]
        class_name: str = structure[key][Default.YAML_CLASS_NAME]
        parts: str = ''.join(
            [
                Classes.generate_specification(key, structure),
                Classes.generate_examples(key, examples),
                Classes.generate_substructures(key, structure),
                Classes.generate_superstructures(key, structure),
                Classes.generate_enumerations(key, structure, enumerationset),
                Classes.generate_value_of(key, structure),
                Classes.generate_args(key, structure),
                Classes.generate_references(key, structure),
            ]
        )
        lines: str = f"""

class {class_name}(BaseStructure):
    '''Store, validate and format the {tag} structure. 
    
    This class was generated by `{__class__.__name__}` from the `{__name__}` module
    using GEDCOM yaml specification files.  Links were added to the specification 
    and tables constructed from the yaml files to aid the user of these classes. 

    DO NOT CHANGE THIS CLASS MANUALLY.  

    {parts}
    '''
    {Classes.generate_init(key, structure)}
    """
        return lines

    @staticmethod
    def generate_all_classes(
        structure: dict[str, dict[str, Any]],
        enumerationset: dict[str, dict[str, Any]],
        examples: dict[str, str],
    ) -> str:
        """Generate all classes and their documentation defined by the Structure dictionary."""

        lines: str = Default.EMPTY
        for key in structure:
            if key not in [Default.CONT, Default.TRLR]:
                lines = ''.join(
                    [
                        lines,
                        Classes.generate_class(
                            key, structure, enumerationset, examples
                        ),
                    ]
                )
        return lines

    @staticmethod
    def build_all(
        source: str,
        version: str,
        structure: dict[str, dict[str, Any]],
        enumerationset: dict[str, dict[str, Any]],
        examples: dict[str, str]
    ) -> str:
        """Construct the entire module containing GEDCOM structures converted to classes.

        To build the classes module one either needs a base directory where the yaml files
        are stored, a base url or a specs module that has already been build.  From the
        specs module one will need the Structure and EnumerationSet dictionaries.

        Example:
            This example constructs a string that could be used for a classes module
            using a specification module that has already been constructed.
            >>> from genedata.prep import Construct
            >>> from genedata.specs7 import Structure, EnumerationSet
            >>> all = Construct.build_all(
            ...     'specify-ged-source', '7.0', '', Structure, EnumerationSet
            ... )

            Alternatively, if one has a directory or yaml files containing the specifications,
            one can enter it as the url.  The sample test directory for these files is
            'tests/prep_test/gedtest'
            >>> all = Construct.build_all(
            ...     'specify-ged-source', '7.0', 'tests/prep_test/gedtest'
            ... )

            Without either a url or the dictionaries a ValueError is returned.
            >>> all = Construct.build_all('specify-ged-source', '7.0')
            Traceback (most recent call last):
            ValueError: Missing both a url and specification dictionaries.

            For testing there is a sample directory of yaml files.  One could use this
            to build a classes module based only on the files available.
            >> all = Construct.build_all('specify-ged-source', '7.0', 'tests/prep_test/gedtest')

            Using a directory that doesn't exist raises another ValueError:
            >>> all = Construct.build_all(
            ...     'specify-ged-source', '7.0', 'directory/does/not/exist/'
            ... )
            Traceback (most recent call last):
            ValueError: The directory "directory/does/not/exist/structure/standard/" could not be found.

        """
        return ''.join(
            [
                Classes.preamble(source, version),
                Classes.generate__all__(structure),
                Classes.generate_imports(),
                Classes.generate_all_classes(structure, enumerationset, examples),
            ]
        )


class Specs:
    """Read and store GEDCOM specification."""

    # enumerationset_dict: ClassVar[dict[str, Any]] = {}

    @staticmethod
    def preamble(source: str, version: str) -> str:
        lines: str = f'''"""Store the GEDCOM verson {version} specifications in a dictionary format from yaml files.

This is a generated module. DO NOT MODIFY THIS MODULE MANUALLY.  

Changes should be made to the `{__class__.__name__}` class in the `{__name__}` module.

The specification was obtained from the [GEDCOM-registeries]({source})
made available under an Apache 2.0 license.

The names of the dictionaries are based on the directories in this registry.  Each yaml file
in the directory is read into a dictionary which is then added to a dictionary named after
the directory.  Other keys besides those in the yaml file have been added
to assist this application to read and write ged files.

The following dictionaries are available.  Each item in the dictionary corresponds to a
single yaml file.
- `Calendar` corresponding to yaml files in the calendar directory.
- `DataType` corresponding to yaml files in the data-type directory.
- `Enumeration` corresponding to yaml files in the enumeration directory.
- `EnumerationSet` corresponding to yaml files in the enumeration-set directory.
- `Month` corresponding to yaml files in the month directory.
- `Structure` corresponding to yaml files in the structure/standard directory.
- `ExtensionStructure` corresponding to yaml files in the structure/extenion directory.
- `Uri` corresponding to yaml files in the uri directory.

Example:
    Suppose one has a new GEDCOM specification to load.  Download the yaml files
    to the standard directory structure used by registries. The subdirectory
    locations are defined in the module `constants` and class `Default`.  Once the
    files are positioned run the following:
    >>> from genedata.load import Specs
    >>> source = 'place where the yaml files were downloaded'
    >>> version = '7.0'
    >>> url = 'stage/v7/'
    >>> print(Specs.build_all(source, version, url))

    The final '/' character on the directory is optional.  The following would also work.
    >>> url = 'stage/v8'
    >>> print(Specs.build_all(source, version, url))

    Copy the output into a python file and call it `specs8.py`.  
    For the example I will use the current specs7.py module.
    To generate the classes import the dictionaries and run `Classes.build_all`.
    >>> from genedata.load import Classes
    >>> from genedata.specs7 import Structure, Enumeration, EnumerationSet
    >>> print(Classes.build_all(Structure, Enumeration, EnumerationSet))

    Place the output into a `classes7.py` python module file.  From this file one
    can build test cases using the Tests class and the specifications.  There are six
    test modules.
    - Basic: Test for good runs without substructures (unless a substructure is required).
    - One Sub: Test for good runs with one substructure (unless more are required).
    - Required: Test to fail validation if they do not have all of their required substructures.
    - Permitted: Test to fail validation if they have substructures not in their permitted set.
    - Single: Test to fail validation if they violate the singuarity requirement for a substructure.
    - Payload: Test to fail validation if not in compliance with their payload datatype.

    To print the first test, run:
    >>> from genedata.load import Tests
    >>> import genedata.classes7 as gc
    >>> basic = Tests.basic(Structure)
    >>> one_sub = Tests.one_sub(Structure)
    >>> required = Tests.required(Structure)
    >>> permitted = Tests.permitted(Structure)
    >>> single = Tests.required(Structure)
    >>> payload = Tests.permitted(Structure)

    Print and save each of these to their own files in a test directory, say `tests/load_v7_test`.
    From there you can run `pytest tests/load_v7_test` to check the classes constructure.

Reference:
    [GEDCOM-registeries]({source})
"""

__all__ = [
    'Calendar',
    'DataType',
    'Enumeration',
    'EnumerationSet',
    'ExtensionStructure',
    'Month',
    'Structure',
    'Uri',
]

from typing import Any

'''
        return lines

    @staticmethod
    def get_enum_tag(value: str) -> str:
        """Extract the tag from the file name specifying an enumeration tag.

        This can also be obtained from the `standard tag` key within that file.

        Example:
            Suppose the file name is "https://gedcom.io/terms/v7/enum-ADOP-HUSB".
            This method returns only HUSB as the tag.
            >>> from genedata.prep import Convert
            >>> print(
            ...     Convert.get_enum_tag(
            ...         '"https://gedcom.io/terms/v7/enum-ADOP-HUSB"'
            ...     )
            ... )
            HUSB

        """
        tag: str = (
            value[value.rfind(Default.SLASH) + 1 :]
            .replace(Default.URL_ENUMERATION_PREFIX, Default.EMPTY)
            .replace(Default.QUOTE_DOUBLE, Default.EMPTY)
        )
        if Default.HYPHEN in tag:
            tag = tag[tag.rfind(Default.HYPHEN) + 1 :]
        return tag

    @staticmethod
    def dictionary(
        url: str,
        base: str,
        prefix: str,
    ) -> str:
        lines: str = Default.BRACE_LEFT
        directory: str = f'{Names.slash(url)}{base}'
        p = Path(directory)
        if p.exists():
            for file in p.iterdir():
                if file.suffix == Default.YAML_FILE_END:
                    key = file.stem.replace(prefix, Default.EMPTY)
                    yamldict = Util.read_yaml(str(file))
                    # match base:
                    #     case (
                    #         Default.URL_STRUCTURE
                    #         | Default.URL_STRUCTURE_EXTENSION
                    #     ):
                    #         required: list[str] = []
                    #         single: list[str] = []
                    #         permitted: list[str] = []
                    #         enumset: str = Default.EMPTY
                    #         if Default.YAML_SUBSTRUCTURES in yamldict:
                    #             for keyname, value in yamldict[
                    #                 Default.YAML_SUBSTRUCTURES
                    #             ].items():
                    #                 tag = (
                    #                     keyname[
                    #                         keyname.rfind(Default.SLASH) + 1 :
                    #                     ]
                    #                     .title()
                    #                     .replace(Default.HYPHEN, Default.EMPTY)
                    #                 )
                    #                 permitted.append(tag)
                    #                 if (
                    #                     Default.YAML_CARDINALITY_REQUIRED
                    #                     in value
                    #                 ):
                    #                     required.append(tag)
                    #                 if (
                    #                     Default.YAML_CARDINALITY_SINGULAR
                    #                     in value
                    #                 ):
                    #                     single.append(tag)
                    #         if Default.YAML_PAYLOAD in yamldict and yamldict[
                    #             Default.YAML_PAYLOAD
                    #         ] in [
                    #             'https://gedcom.io/terms/v7/type-List#Enum',
                    #             'https://gedcom.io/terms/v7/type-Enum',
                    #         ]:
                    #             enumset = yamldict[Default.YAML_ENUMERATION_SET]

                    #         yamldict[Default.YAML_PERMITTED] = permitted
                    #         yamldict[Default.YAML_REQUIRED] = required
                    #         yamldict[Default.YAML_SINGULAR] = single
                    #         yamldict[Default.YAML_ENUMERATION_SET] = enumset
                    #         yamldict[Default.YAML_ENUM_KEY] = enumset[
                    #             enumset.rfind(Default.SLASH) + 1 :
                    #         ].replace(
                    #             Default.URL_ENUMERATION_SET_PREFIX,
                    #             Default.EMPTY,
                    #         )
                    #         yamldict[Default.YAML_CLASS_NAME] = (
                    #             file.stem.title()
                    #             .replace(Default.UNDERLINE, Default.EMPTY)
                    #             .replace(Default.HYPHEN, Default.EMPTY)
                    #         )
                    #         yamldict[Default.YAML_KEY] = file.stem
                    #     case Default.URL_ENUMERATION_SET:
                    #         enum_tags: list[str] = []
                    #         for tag in yamldict[
                    #             Default.YAML_ENUMERATION_VALUES
                    #         ]:
                    #             enum_tags.append(Convert.get_enum_tag(tag))
                    #         yamldict[Default.YAML_ENUM_TAGS] = enum_tags
                    lines = f"{lines}{Default.EOL}    '{key}': {yamldict},"
        else:
            raise ValueError(Msg.DIRECTORY_NOT_FOUND.format(directory))
        if lines == Default.BRACE_LEFT:
            return ''.join([lines, Default.BRACE_RIGHT])
        return ''.join([lines, Default.EOL, Default.BRACE_RIGHT])

    @staticmethod
    def calendar_dictionary(url: str) -> str:
        """Retrive the calendar dictionary as a string that can be sent to `eval`."""
        return Specs.dictionary(
            url, Default.URL_CALENDAR, Default.URL_CALENDAR_PREFIX
        )

    @staticmethod
    def calendar(url: str) -> str:
        """Format the calendar dictionary for use in the specs module."""
        return ''.join(
            [
                'Calendar: dict[str, dict[str, Any]] = ',
                Specs.calendar_dictionary(url),
                Default.EOL,
                Default.EOL,
            ]
        )

    @staticmethod
    def datatype_dictionary(url: str) -> str:
        """Retrive the data type dictionary as a string that can be sent to `eval`."""
        return Specs.dictionary(
            url, Default.URL_DATATYPE, Default.URL_DATATYPE_PREFIX
        )

    @staticmethod
    def datatype(url: str) -> str:
        """Format the data type dictionary for use in the specs module."""
        return ''.join(
            [
                'DataType: dict[str, dict[str, Any]] = ',
                Specs.datatype_dictionary(url),
                Default.EOL,
                Default.EOL,
            ]
        )

    @staticmethod
    def enumeration_dictionary(url: str) -> str:
        """Retrive the enumeration dictionary as a string that can be sent to `eval`."""
        return Specs.dictionary(
            url, Default.URL_ENUMERATION_SET, Default.URL_ENUMERATION_SET_PREFIX
        )

    @staticmethod
    def enumeration(url: str) -> str:
        """Format the enumeration dictionary for use in the specs module."""
        return ''.join(
            [
                'Enumeration: dict[str, dict[str, Any]] = ',
                Specs.enumeration_dictionary(url),
                Default.EOL,
                Default.EOL,
            ]
        )

    @staticmethod
    def enumerationset_dictionary(url: str) -> str:
        """Retrive the enumeration set dictionary as a string that can be sent to `eval`."""
        return Specs.dictionary(
            url, Default.URL_ENUMERATION_SET, Default.URL_ENUMERATION_SET_PREFIX
        )

    @staticmethod
    def enumerationset(url: str) -> str:
        """Format the enumeration set dictionary for use in the specs module."""
        return ''.join(
            [
                'EnumerationSet: dict[str, dict[str, Any]] = ',
                Specs.enumerationset_dictionary(url),
                Default.EOL,
                Default.EOL,
            ]
        )

    @staticmethod
    def month_dictionary(url: str) -> str:
        """Retrive the month dictionary as a string that can be sent to `eval`."""
        return Specs.dictionary(
            url, Default.URL_MONTH, Default.URL_MONTH_PREFIX
        )

    @staticmethod
    def month(url: str) -> str:
        """Format the month dictionary for use in the specs module."""
        return ''.join(
            [
                'Month: dict[str, dict[str, Any]] = ',
                Specs.month_dictionary(url),
                Default.EOL,
                Default.EOL,
            ]
        )

    @staticmethod
    def structure_dictionary(url: str) -> str:
        """Retrive the structure dictionary as a string that can be sent to `eval`."""
        return Specs.dictionary(
            url, Default.URL_STRUCTURE, Default.URL_STRUCTURE_PREFIX
        )

    @staticmethod
    def structure(url: str) -> str:
        """Format the structure dictionary for use in the specs module."""
        return ''.join(
            [
                'Structure: dict[str, dict[str, Any]] = ',
                Specs.structure_dictionary(url),
                Default.EOL,
                Default.EOL,
            ]
        )

    @staticmethod
    def structure_extension_dictionary(url: str) -> str:
        """Retrive the extension structure dictionary as a string that can be sent to `eval`."""
        return Specs.dictionary(
            url,
            Default.URL_STRUCTURE_EXTENSION,
            Default.URL_STRUCTURE_EXTENSION_PREFIX,
        )

    @staticmethod
    def structure_extension(url: str) -> str:
        """Format the extension structure dictionary for use in the specs module."""
        return ''.join(
            [
                'ExtensionStructure: dict[str, dict[str, Any]] = ',
                Specs.structure_extension_dictionary(url),
                Default.EOL,
                Default.EOL,
            ]
        )

    @staticmethod
    def uri_dictionary(url: str) -> str:
        """Retrive the uri dictionary as a string that can be sent to `eval`."""
        return Specs.dictionary(url, Default.URL_URI, Default.URL_URI_PREFIX)

    @staticmethod
    def uri(url: str) -> str:
        """Format the uri dictionary for use in the specs module."""
        return ''.join(
            [
                'Uri: dict[str, dict[str, Any]] = ',
                Specs.uri_dictionary(url),
                Default.EOL,
                Default.EOL,
            ]
        )

    @staticmethod
    def build_all(source: str, version: str, url: str) -> str:
        return ''.join(
            [
                Specs.preamble(source, version),
                Specs.calendar(url),
                Specs.datatype(url),
                Specs.enumeration(url),
                Specs.enumerationset(url),
                Specs.month(url),
                Specs.structure(url),
                Specs.structure_extension(url),
                Specs.uri(url),
            ]
        )


class Tests:
    """Generate tests for the classes based on the specifications."""

    @staticmethod
    def preamble(name: str, version: str = '7') -> str:
        extra_import: str = Default.EMPTY
        if name in [Default.TEST_PAYLOAD, Default.TEST_REQUIRED, Default.TEST_PERMITTED, Default.TEST_SINGLE]:
            extra_import = '\n\nimport pytest\n\n'
        return f"""The {name} tests in this module were generated by {__class__.__name__} in the {__name__} module.

DO NOT MODIFY THIS FILE MANUALLY.{extra_import}

import genedata.classes{version} as {Default.CODE_CLASS}
from genedata.build import Genealogy

"""
    
    @staticmethod
    def build_all(name: str, version: str = '7', structure: dict[str, dict[str,Any]]) -> str:
        lines: str = Tests.preamble(name, version)
        
        return lines
        

    @staticmethod
    def no_subs_good_test(
        key: str, value: str | int, xref: str = Default.EMPTY
    ) -> str:
        class_name: str = Names.classname(key)
        xref_code: str = Default.EMPTY
        input: str | int = f"'{value}'"
        if value == Default.EMPTY:
            input = ''
        if isinstance(value, int):
            input = value
        if xref != Default.EMPTY:
            input = f'{xref}'
            xref_code = f"""g = Genealogy('test')
    {xref} = g.{xref}_xref('1')
    """
            if xref == 'shared_note':
                xref_code = """g = Genealogy('test')
    shared_note = g.shared_note_xref('1', 'text')
    """
        lines: str = f"""

def test_no_subs_{class_name}() -> None:
    '''Validate the {class_name} structure with a value, but without substructures.'''
    {xref_code}m = {Default.CODE_CLASS}.{class_name}({input})
    assert m.validate()
"""
        return lines

    @staticmethod
    def build_no_subs_good_tests(
        structure: dict[str, dict[str, Any]],
        enumerationset: dict[str, dict[str, Any]],
    ) -> str:
        lines: str = f"""'''The tests in this file have been generated from the specs module
to test the classes in the classes module.  None of these have required substructures
nor exercise the use ob substructures.

DO NOT MANUALLY MODIFY THIS FILE.
'''

import genedata.classes{Config.VERSION} as {Default.CODE_CLASS}
from genedata.build import Genealogy
"""
        input: str = 'abc'
        for key, value in structure.items():
            if len(value[Default.YAML_REQUIRED]) == 0 and key not in [
                Default.TRLR,
                Default.CONT,
            ]:
                match value[Default.YAML_PAYLOAD]:
                    case 'http://www.w3.org/2001/XMLSchema#string':
                        match key:
                            case 'LATI':
                                lines = ''.join(
                                    [
                                        lines,
                                        Tests.no_subs_good_test(key, 'N10.1'),
                                    ]
                                )
                            case 'LONG':
                                lines = ''.join(
                                    [
                                        lines,
                                        Tests.no_subs_good_test(key, 'E10.1'),
                                    ]
                                )
                            case 'record-SNOTE':
                                lines = ''.join(
                                    [
                                        lines,
                                        Tests.no_subs_good_test(
                                            key, '', 'shared_note'
                                        ),
                                    ]
                                )
                            case _:
                                lines = ''.join(
                                    [lines, Tests.no_subs_good_test(key, input)]
                                )
                    case 'Y|<NULL>':
                        lines = ''.join(
                            [lines, Tests.no_subs_good_test(key, 'Y')]
                        )
                    case None:
                        match key:
                            case 'record-INDI':
                                lines = ''.join(
                                    [
                                        lines,
                                        Tests.no_subs_good_test(
                                            key, '', 'individual'
                                        ),
                                    ]
                                )
                            case 'record-FAM':
                                lines = ''.join(
                                    [
                                        lines,
                                        Tests.no_subs_good_test(
                                            key, '', 'family'
                                        ),
                                    ]
                                )
                            # case 'record-SNOTE':
                            #     lines = ''.join(
                            #         [
                            #             lines,
                            #             Tests.no_subs_good_test(
                            #                 key, '', 'shared_note'
                            #             ),
                            #         ]
                            #     )
                            case 'record-SOUR':
                                lines = ''.join(
                                    [
                                        lines,
                                        Tests.no_subs_good_test(
                                            key, '', 'source'
                                        ),
                                    ]
                                )
                            case _:
                                lines = ''.join(
                                    [lines, Tests.no_subs_good_test(key, '')]
                                )
                    case 'https://gedcom.io/terms/v7/type-Enum':
                        enum = enumerationset[value[Default.YAML_ENUM_KEY]][
                            Default.YAML_ENUM_TAGS
                        ][0]
                        lines = ''.join(
                            [lines, Tests.no_subs_good_test(key, enum)]
                        )
                    case 'http://www.w3.org/2001/XMLSchema#nonNegativeInteger':
                        lines = ''.join(
                            [lines, Tests.no_subs_good_test(key, 1)]
                        )
                    case '@<https://gedcom.io/terms/v7/record-INDI>@':
                        lines = ''.join(
                            [
                                lines,
                                Tests.no_subs_good_test(key, '', 'individual'),
                            ]
                        )
                    case '@<https://gedcom.io/terms/v7/record-FAM>@':
                        lines = ''.join(
                            [lines, Tests.no_subs_good_test(key, '', 'family')]
                        )
                    case 'https://gedcom.io/terms/v7/type-List#Text':
                        lines = ''.join(
                            [lines, Tests.no_subs_good_test(key, input)]
                        )
                    case '@<https://gedcom.io/terms/v7/record-SUBM>@':
                        lines = ''.join(
                            [
                                lines,
                                Tests.no_subs_good_test(key, '', 'submitter'),
                            ]
                        )
                    case 'http://www.w3.org/2001/XMLSchema#Language':
                        lines = ''.join(
                            [lines, Tests.no_subs_good_test(key, 'en-US')]
                        )
                    case 'https://gedcom.io/terms/v7/type-Date#period':
                        lines = ''.join(
                            [
                                lines,
                                Tests.no_subs_good_test(
                                    key, 'FROM 1 DEC 2000 TO 5 DEC 2000'
                                ),
                            ]
                        )
                    case 'https://gedcom.io/terms/v7/type-List#Enum':
                        enum = enumerationset[value[Default.YAML_ENUM_KEY]][
                            Default.YAML_ENUM_TAGS
                        ][0]
                        lines = ''.join(
                            [lines, Tests.no_subs_good_test(key, enum)]
                        )
                    case 'https://gedcom.io/terms/v7/type-Date#exact':
                        lines = ''.join(
                            [lines, Tests.no_subs_good_test(key, '1 JAN 2026')]
                        )
                    case 'https://gedcom.io/terms/v7/type-Date':
                        lines = ''.join(
                            [lines, Tests.no_subs_good_test(key, '1 JAN 2026')]
                        )
                    # case 'https://gedcom.io/terms/v7/type-FilePath':
                    #     lines = ''.join(
                    #         [
                    #             lines,
                    #             Tests.no_subs_good_test(
                    #                 key, 'dir/to/somewhere'
                    #             ),
                    #         ]
                    #     )
                    case 'http://www.w3.org/ns/dcat#mediaType':
                        lines = ''.join(
                            [lines, Tests.no_subs_good_test(key, 'mime/text')]
                        )
                    case 'https://gedcom.io/terms/v7/type-Name':
                        lines = ''.join(
                            [lines, Tests.no_subs_good_test(key, 'John /Doe/')]
                        )
                    case 'https://gedcom.io/terms/v7/type-Age':
                        lines = ''.join(
                            [
                                lines,
                                Tests.no_subs_good_test(key, '> 25y 10m 1d'),
                            ]
                        )
                    case '@<https://gedcom.io/terms/v7/record-OBJE>@':
                        lines = ''.join(
                            [
                                lines,
                                Tests.no_subs_good_test(key, '', 'multimedia'),
                            ]
                        )
                    case '@<https://gedcom.io/terms/v7/record-REPO>@':
                        lines = ''.join(
                            [
                                lines,
                                Tests.no_subs_good_test(key, '', 'repository'),
                            ]
                        )
                    case '@<https://gedcom.io/terms/v7/record-SNOTE>@':
                        lines = ''.join(
                            [
                                lines,
                                Tests.no_subs_good_test(key, '', 'shared_note'),
                            ]
                        )
                    case '@<https://gedcom.io/terms/v7/record-SOUR>@':
                        lines = ''.join(
                            [lines, Tests.no_subs_good_test(key, '', 'source')]
                        )
                    case 'https://gedcom.io/terms/v7/type-Time':
                        lines = ''.join(
                            [lines, Tests.no_subs_good_test(key, '12:12:12')]
                        )
        return lines

    @staticmethod
    def one_sub_good_test(
        key: str,
        value: str | int,
        sub_class_name: str,
        xref: str = Default.EMPTY,
    ) -> str:
        class_name: str = Names.classname(key)
        xref_code: str = Default.EMPTY
        sub_input: str | int = "'abc'"
        match sub_class_name:
            case 'DateExact':
                sub_input = "'1 JAN 2000'"
            case 'Form':
                sub_input = "'text/html'"
            case 'Role':
                sub_input = "'WITN'"
            case 'Type':
                sub_input = "'Bishop'"
            case 'Age':
                sub_input = "'> 25y'"
        # if isinstance(value, int):
        #     sub_input = sub_value
        input: str | int = f"'{value}'"
        if isinstance(value, int):
            input = value
        if xref != Default.EMPTY:
            input = f'{xref}'
            xref_code = f"""g = Genealogy('test')
    {xref} = g.{xref}_xref('1')
    """
    #         if xref == 'shared_note':
    #             xref_code = """g = Genealogy('test')
    # shared_note = g.shared_note_xref('1', 'text')
    # """
        lines: str = f"""

def test_one_sub_{class_name}() -> None:
    '''Validate the {class_name} structure with a value and one substructure.'''
    {xref_code}m = {Default.CODE_CLASS}.{class_name}({input}, {Default.CODE_CLASS}.{sub_class_name}({sub_input}))
    assert m.validate()
"""
        return lines

    @staticmethod
    def build_one_sub_good_tests(
        structure: dict[str, dict[str, Any]],
        enumerationset: dict[str, dict[str, Any]],
    ) -> str:
        lines: str = f"""'''The {Default.TEST_BASE} tests in this file have been generated 
from the `{__class__.__name__}` class of the `{__name__}` module.

DO NOT MANUALLY MODIFY THIS FILE.
'''

import genedata.classes{Config.VERSION} as {Default.CODE_CLASS}
from genedata.build import Genealogy
"""
        input: str = 'abc'
        for key, value in structure.items():
            if (
                key not in [Default.TRLR, Default.CONT]
                and len(value[Default.YAML_REQUIRED]) < 2
                and len(value[Default.YAML_PERMITTED]) > 0
            ):
                sub_permitted: list[str] = value[Default.YAML_PERMITTED]
                sub_class_name: str = Default.EMPTY
                for item in [
                    'Age',
                    'DateExact',
                    'Form',
                    'Gedc',
                    'GedcVers',
                    'HeadPlacForm',
                    'Mime',
                    'Name',
                    'Note',
                    'Phrase',
                    'Phon',
                    'Role',
                    'Time',
                    'Titl',
                    'Type',
                ]:
                    if item in sub_permitted:
                        sub_class_name = item
                        break
                if len(value[Default.YAML_REQUIRED]) == 1:
                    sub_class_name = value[Default.YAML_REQUIRED][0]
                if sub_class_name != Default.EMPTY:
                    match value[Default.YAML_PAYLOAD]:
                        case 'http://www.w3.org/2001/XMLSchema#string':
                            # match key:
                            #     case 'LATI':
                            #         lines = ''.join(
                            #             [
                            #                 lines,
                            #                 Tests.one_sub_good_test(
                            #                     key, 'N10.1', sub_class_name
                            #                 ),
                            #             ]
                            #         )
                            #     case 'LONG':
                            #         lines = ''.join(
                            #             [
                            #                 lines,
                            #                 Tests.one_sub_good_test(
                            #                     key, 'E10.1', sub_class_name
                            #                 ),
                            #             ]
                            #         )
                            #     case 'record-SNOTE':
                            #         lines = ''.join(
                            #             [
                            #                 lines,
                            #                 Tests.one_sub_good_test(
                            #                     key,
                            #                     '',
                            #                     sub_class_name,
                            #                     'shared_note',
                            #                 ),
                            #             ]
                            #         )
                            #     case _:
                            lines = ''.join(
                                [
                                    lines,
                                    Tests.one_sub_good_test(
                                        key, input, sub_class_name
                                    ),
                                ]
                            )
                        case 'Y|<NULL>':
                            lines = ''.join(
                                [
                                    lines,
                                    Tests.one_sub_good_test(
                                        key, 'Y', sub_class_name
                                    ),
                                ]
                            )
                        case None:
                            match key:
                                case 'record-INDI':
                                    lines = ''.join(
                                        [
                                            lines,
                                            Tests.one_sub_good_test(
                                                key,
                                                '',
                                                sub_class_name,
                                                'individual',
                                            ),
                                        ]
                                    )
                                case 'record-FAM':
                                    lines = ''.join(
                                        [
                                            lines,
                                            Tests.one_sub_good_test(
                                                key,
                                                '',
                                                sub_class_name,
                                                'family',
                                            ),
                                        ]
                                    )
                                # case 'record-SNOTE':
                                #     lines = ''.join(
                                #         [
                                #             lines,
                                #             Tests.one_sub_good_test(
                                #                 key,
                                #                 '',
                                #                 sub_class_name,
                                #                 'shared_note',
                                #             ),
                                #         ]
                                #     )
                        case 'https://gedcom.io/terms/v7/type-Enum':
                            enum = enumerationset[value[Default.YAML_ENUM_KEY]][
                                Default.YAML_ENUM_TAGS
                            ][0]
                            lines = ''.join(
                                [
                                    lines,
                                    Tests.one_sub_good_test(
                                        key, enum, sub_class_name
                                    ),
                                ]
                            )
                        case 'http://www.w3.org/2001/XMLSchema#nonNegativeInteger':
                            lines = ''.join(
                                [
                                    lines,
                                    Tests.one_sub_good_test(
                                        key, 1, sub_class_name
                                    ),
                                ]
                            )
                        case '@<https://gedcom.io/terms/v7/record-INDI>@':
                            lines = ''.join(
                                [
                                    lines,
                                    Tests.one_sub_good_test(
                                        key, '', sub_class_name, 'individual'
                                    ),
                                ]
                            )
                        case '@<https://gedcom.io/terms/v7/record-FAM>@':
                            lines = ''.join(
                                [
                                    lines,
                                    Tests.one_sub_good_test(
                                        key, '', sub_class_name, 'family'
                                    ),
                                ]
                            )
                        case 'https://gedcom.io/terms/v7/type-List#Text':
                            lines = ''.join(
                                [
                                    lines,
                                    Tests.one_sub_good_test(
                                        key, input, sub_class_name
                                    ),
                                ]
                            )
                        # case '@<https://gedcom.io/terms/v7/record-SUBM>@':
                        #     lines = ''.join(
                        #         [
                        #             lines,
                        #             Tests.one_sub_good_test(
                        #                 key, '', sub_class_name, 'submitter'
                        #             ),
                        #         ]
                        #     )
                        # case 'http://www.w3.org/2001/XMLSchema#Language':
                        #     lines = ''.join(
                        #         [
                        #             lines,
                        #             Tests.one_sub_good_test(
                        #                 key, 'en-US', sub_class_name
                        #             ),
                        #         ]
                        #     )
                        case 'https://gedcom.io/terms/v7/type-Date#period':
                            lines = ''.join(
                                [
                                    lines,
                                    Tests.one_sub_good_test(
                                        key,
                                        'FROM 1 DEC 2000 TO 5 DEC 2000',
                                        sub_class_name,
                                    ),
                                ]
                            )
                        # case 'https://gedcom.io/terms/v7/type-List#Enum':
                        #     enum = enumerationset[value[Default.YAML_ENUM_KEY]][
                        #         Default.YAML_ENUM_TAGS
                        #     ][0]
                        #     lines = ''.join(
                        #         [
                        #             lines,
                        #             Tests.one_sub_good_test(
                        #                 key, enum, sub_class_name
                        #             ),
                        #         ]
                        #     )
                        case 'https://gedcom.io/terms/v7/type-Date#exact':
                            lines = ''.join(
                                [
                                    lines,
                                    Tests.one_sub_good_test(
                                        key, '1 JAN 2026', sub_class_name
                                    ),
                                ]
                            )
                        case 'https://gedcom.io/terms/v7/type-Date':
                            lines = ''.join(
                                [
                                    lines,
                                    Tests.one_sub_good_test(
                                        key, '1 JAN 2026', sub_class_name
                                    ),
                                ]
                            )
                        case 'https://gedcom.io/terms/v7/type-FilePath':
                            lines = ''.join(
                                [
                                    lines,
                                    Tests.one_sub_good_test(
                                        key, 'dir/to/somewhere', sub_class_name
                                    ),
                                ]
                            )
                        # case 'http://www.w3.org/ns/dcat#mediaType':
                        #     lines = ''.join(
                        #         [
                        #             lines,
                        #             Tests.one_sub_good_test(
                        #                 key, 'mime/text', sub_class_name
                        #             ),
                        #         ]
                        #     )
                        case 'https://gedcom.io/terms/v7/type-Name':
                            lines = ''.join(
                                [
                                    lines,
                                    Tests.one_sub_good_test(
                                        key, 'John /Doe/', sub_class_name
                                    ),
                                ]
                            )
                        case 'https://gedcom.io/terms/v7/type-Age':
                            lines = ''.join(
                                [
                                    lines,
                                    Tests.one_sub_good_test(
                                        key, '> 25y 10m 1d', sub_class_name
                                    ),
                                ]
                            )
                        case '@<https://gedcom.io/terms/v7/record-OBJE>@':
                            lines = ''.join(
                                [
                                    lines,
                                    Tests.one_sub_good_test(
                                        key, '', sub_class_name, 'multimedia'
                                    ),
                                ]
                            )
                        case '@<https://gedcom.io/terms/v7/record-REPO>@':
                            lines = ''.join(
                                [
                                    lines,
                                    Tests.one_sub_good_test(
                                        key, '', sub_class_name, 'repository'
                                    ),
                                ]
                            )
                        # case '@<https://gedcom.io/terms/v7/record-SNOTE>@':
                        #     lines = ''.join(
                        #         [
                        #             lines,
                        #             Tests.one_sub_good_test(
                        #                 key, '', sub_class_name, 'shared_note'
                        #             ),
                        #         ]
                        #     )
                        case '@<https://gedcom.io/terms/v7/record-SOUR>@':
                            lines = ''.join(
                                [
                                    lines,
                                    Tests.one_sub_good_test(
                                        key, '', sub_class_name, 'source'
                                    ),
                                ]
                            )
                        # case 'https://gedcom.io/terms/v7/type-Time':
                        #     lines = ''.join(
                        #         [
                        #             lines,
                        #             Tests.one_sub_good_test(
                        #                 key, '12:12:12', sub_class_name
                        #             ),
                        #         ]
                        #     )
        return lines
